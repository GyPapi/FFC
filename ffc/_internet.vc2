*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="_internet.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS _cookie AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: fixurl		&& Reads and cleans up URL for reading cookie.
		*m: getcookie		&& Gets cookie from HTML.
		*m: getval		&& Retrieves value from given string.
		*m: makecookie		&& Generates unique cookie based on system datetime.
		*m: writecookieinfo		&& Writes cookie information to cookie table.
		*p: ccookie		&& Name of current cookie.
		*p: cookietable		&& Name of cookie table.
		*p: dbfalias		&& Alias of cookie table.
	*</DefinedPropArrayMethod>

	ccookie = 		&& Name of current cookie.
	cookietable = cookies.dbf		&& Name of cookie table.
	dbfalias = 		&& Alias of cookie table.
	Name = "_cookie"
	
	PROCEDURE fixurl		&& Reads and cleans up URL for reading cookie.
		LPARAMETERS  m.cStr
		LOCAL m.n1,m.rv
		m.cstr=STRTRAN(m.cstr,"+"," ")
		m.rv = ""
		DO WHILE .T.
			IF "%" $ m.cStr
				m.n1 = AT('%',m.cStr)
				IF m.n1 > LEN(m.cStr) - 2
					m.rv = m.rv + m.cStr
					EXIT
				ENDIF
				IF atc(SUBSTR(m.cStr,m.n1+1,1),"0123456789ABCDEF")=0 && not hex digit
					m.rv = m.rv + LEFT(m.cStr,m.n1)
					m.cStr = SUBSTR(m.cStr,m.n1+1)
					LOOP
				ENDIF
				m.rv = m.rv + LEFT(m.cStr,m.n1-1) + ;
					CHR(EVAL("0x"+SUBSTR(m.cStr,m.n1+1,2)))
				IF LEN(m.cStr) > m.n1 + 2
					m.cStr = SUBSTR(m.cStr,m.n1+3)
				ELSE
					EXIT
				ENDIF
			ELSE
				m.rv = m.rv + m.cStr
				EXIT
			ENDIF
		ENDDO
		m.cStr = m.rv
		RETURN m.rv
		
	ENDPROC

	PROCEDURE getcookie		&& Gets cookie from HTML.
		LPARAMETERS cStr
		THIS.FixURL(@m.cStr)
		*Get the cookie value from either a parameter or a 
		*hidden input field
		IF "Cookie="$ m.cStr
			THIS.cCookie=THIS.getval(m.cStr,"Cookie")
			m.cStr = STRTRAN(m.cStr,"&Cookie=")
			m.cStr = STRTRAN(m.cStr,"Cookie=")
		ELSE
			THIS.cCookie= LEFT(m.cStr,LEN(THIS.MakeCookie()))
		ENDIF
		cStr = STRTRAN(m.cStr,THIS.cCookie,"")
		IF !SEEK(THIS.cCookie,"cookies")
			INSERT INTO cookies (cookie) VALUES (THIS.cCookie)
		ELSE
			IF !EMPTY(THIS.dbfAlias)
				GOTO (cookies.rnum) IN (THIS.dbfAlias)
			ENDIF
		ENDIF
		RETURN m.cstr
		
	ENDPROC

	PROCEDURE getval		&& Retrieves value from given string.
		LPARAMETERS cstr,cVal
		LOCAL n1,c2
		n1 = AT(m.cVal,m.cStr)
		IF n1 = 0
			return ""
		ENDIF
		c2 = ALLTRIM(SUBSTR(m.cStr,n1 + LEN(m.cVal)))
		IF LEFT(m.c2,1) = '='
			c2 = SUBSTR(m.c2,2)
		ENDIF
		IF "&"$c2
			RETURN ALLTRIM(LEFT(m.c2,AT('&',m.c2)-1))
		ELSE
			RETURN ALLTRIM(m.c2)
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		* We could present the user with a Login screen, 
		* and use the username as a key for the cookie.
		LOCAL cCookieDBF
		IF EMPTY(THIS.CookieTable)
			RETURN .F.
		ENDIF
		cCookieDBF = IIF(EMPTY(TRAN(THIS.CookieTable)),C_DEFCOOKIEDBF,THIS.CookieTable)
		IF !FILE(m.cCookieDBF)
			* a table to store user state based on a cookie (timestamp)
			CREATE TABLE (m.cCookieDBF) free (cookie c(20), rnum i, extra c(10))	
			INDEX ON cookie TAG cookie
		ENDIF
		USE (m.cCookieDBF) ALIAS cookies ORDER 1  && Reopen shared
		THIS.CookieTable = m.cCookieDBF
		THIS.dbfAlias=ALIAS()
		
	ENDPROC

	PROCEDURE makecookie		&& Generates unique cookie based on system datetime.
		RETURN STRTRAN(STRTRAN(TIME()+ PADL(SECONDS(),10,'0'),":",""),".","")
		
	ENDPROC

	PROCEDURE writecookieinfo		&& Writes cookie information to cookie table.
		IF !EMPTY(THIS.cCookie)
			SELECT cookies
			SEEK THIS.cCookie
			IF !FOUND()
				INSERT INTO cookies (cookie) VALUES (THIS.cCookie)
			ENDIF
			IF !EMPTY(THIS.dbfAlias)
				REPLACE rnum WITH RECNO(THIS.dbfAlias)
			ENDIF
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _dbf2html AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: genhtml		&& Generates HTML calling _GENHTML engine.
		*p: coutfile		&& This is name of HTM file to output.
		*p: cscope		&& The scope of records to process (e.g., NEXT 1, REST).
		*p: csource		&& This is source file from which to generate HTML.
		*p: cstyle		&& The registered style to use for visual display.
		*p: lautonameoutput		&& Causes _GENHTML to automatically name the output file based on source.
		*p: lusecurrentalias		&& Use current alias as source.
		*p: ngenoutput		&& _GENHTML output options. See _GENHTML file header.
	*</DefinedPropArrayMethod>

	coutfile = 		&& This is name of HTM file to output.
	cscope = 		&& The scope of records to process (e.g., NEXT 1, REST).
	csource = 		&& This is source file from which to generate HTML.
	cstyle = 		&& The registered style to use for visual display.
	lautonameoutput = .T.		&& Causes _GENHTML to automatically name the output file based on source.
	lusecurrentalias = .T.		&& Use current alias as source.
	Name = "_dbf2html"
	ngenoutput = 2		&& _GENHTML output options. See _GENHTML file header.
	
	PROCEDURE genhtml		&& Generates HTML calling _GENHTML engine.
		LOCAL lcSource
		
		IF VARTYPE(THIS.lUseCurrentAlias)="L" AND; 
			THIS.lUseCurrentAlias AND !EMPTY(ALIAS())
			lcSource=ALIAS()
		ENDIF
		
		IF EMPTY(lcSource)
			lcSource=this.cSource
			IF !FILE(lcSource)
				lcSource = GETFILE("DBF")
				IF EMPTY(lcSource) OR !FILE(lcSource)
					RETURN .F.
				ENDIF
			ENDIF
		ENDIF
		
		this.cSource=lcSource
		IF VARTYPE(THIS.lAutoNameOutput)="L" AND; 
			THIS.lAutoNameOutput
			THIS.cOutFile = FORCEEXT(lcSource,"HTM")
		ENDIF
		
		DO (_GENHTML) WITH (this.cOutFile),(this.cSource),(this.nGenOutput),"",(this.cStyle),(this.cScope)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _frx2html AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: genhtml		&& Generates HTML calling _GENHTML engine.
		*p: coutfile		&& This is name of HTM file to output.
		*p: cscope		&& The scope of records to process (e.g., NEXT 1, REST).
		*p: csource		&& This is source file from which to generate HTML.
		*p: cstyle		&& The registered style to use for visual display (tables only).
		*p: lautonameoutput		&& Causes _GENHTML to automatically name the output file based on source.
		*p: lcreatetempreport		&& Whether to automatically create a new temp report if DBF passed.
		*p: ngenoutput		&& _GENHTML output options. See _GENHTML file header.
	*</DefinedPropArrayMethod>

	coutfile = 		&& This is name of HTM file to output.
	cscope = 		&& The scope of records to process (e.g., NEXT 1, REST).
	csource = 		&& This is source file from which to generate HTML.
	cstyle = 		&& The registered style to use for visual display (tables only).
	lautonameoutput = .T.		&& Causes _GENHTML to automatically name the output file based on source.
	lcreatetempreport = .T.		&& Whether to automatically create a new temp report if DBF passed.
	Name = "_frx2html"
	ngenoutput = 2		&& _GENHTML output options. See _GENHTML file header.
	
	PROCEDURE genhtml		&& Generates HTML calling _GENHTML engine.
		LOCAL lcSource,lcReport,lcSafety
		
		lcSource = THIS.cSource
		IF VARTYPE(lcSource)#"C" OR !FILE(lcSource)
			lcSource = GETFILE("FRX")
			IF !FILE(lcSource)
				RETURN .F.
			ENDIF
		ENDIF
		
		THIS.cSource = lcSource
		
		IF UPPER(JUSTEXT(lcSource))="DBF" 
			IF THIS.lCreateTempReport
				lcSafety = SET("SAFETY")
				SET SAFETY OFF
				lcReport = SYS(2023)+"\"+ JUSTFNAME(FORCEEXT(lcSource,"FRX"))
				CREATE REPORT (lcReport) FROM (lcSource)
				SET SAFETY &lcSafety
				THIS.cSource = lcReport
			ELSE
				RETURN .F.
			ENDIF
		ENDIF
		
		IF VARTYPE(THIS.lAutoNameOutput)="L" AND; 
			THIS.lAutoNameOutput
			THIS.cOutFile = FORCEEXT(lcSource,"HTM")
		ENDIF
		
		DO (_GENHTML) WITH (this.cOutFile),(this.cSource),(this.nGenOutput),"",(this.cStyle),(this.cScope)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _openaddressdialog AS _dialog OF "_dialogs.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="imgOpenInternetAddress" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblHeader1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblOpen" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboURL" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOK" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdCancel" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdOpenFile" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oShellExecute" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*p: cfileext
		*p: ctarget		&& Name of target URL.
		*p: lshellexecute		&& Executes selected URL.
	*</DefinedPropArrayMethod>

	Caption = "Open"
	cfileext = htm;html;asp;txt;doc;xls;ppt;gif;jpg;jpeg;au;aiff;xbm;app
	ctarget = 		&& Name of target URL.
	DoCreate = .T.
	Height = 121
	Icon = graphics\hyperlink.ico
	lshellexecute = .T.		&& Executes selected URL.
	Name = "_openaddressdialog"
	ShowWindow = 1
	Width = 339
	WindowType = 1

	ADD OBJECT 'cboURL' AS _urlcombobox WITH ;
		Height = 23, ;
		Left = 63, ;
		lformnavigate = .T., ;
		Name = "cboURL", ;
		TabIndex = 4, ;
		Top = 57, ;
		Width = 267
		*< END OBJECT: ClassLib="_internet.vcx" BaseClass="combobox" />

	ADD OBJECT 'cmdCancel' AS commandbutton WITH ;
		Caption = "Cancel", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 175, ;
		Name = "cmdCancel", ;
		TabIndex = 7, ;
		Top = 86, ;
		Width = 75
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOK' AS commandbutton WITH ;
		Caption = "OK", ;
		Default = .T., ;
		Enabled = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 94, ;
		Name = "cmdOK", ;
		TabIndex = 6, ;
		Top = 86, ;
		Width = 75
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'cmdOpenFile' AS commandbutton WITH ;
		Caption = "\<Browse...", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 256, ;
		Name = "cmdOpenFile", ;
		TabIndex = 8, ;
		Top = 86, ;
		Width = 75
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'imgOpenInternetAddress' AS image WITH ;
		Height = 36, ;
		Left = 8, ;
		Name = "imgOpenInternetAddress", ;
		Picture = graphics\openadlg.bmp, ;
		Top = 12, ;
		Width = 42
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'lblHeader1' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Type the Internet address of a document or folder.", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 64, ;
		Name = "lblHeader1", ;
		TabIndex = 1, ;
		Top = 22, ;
		Width = 264
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblOpen' AS label WITH ;
		BackStyle = 0, ;
		Caption = "\<Open:", ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 18, ;
		Left = 13, ;
		Name = "lblOpen", ;
		Top = 57, ;
		Width = 51
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'oShellExecute' AS _shellexecute WITH ;
		Left = 310, ;
		Name = "oShellExecute", ;
		Top = 10
		*< END OBJECT: ClassLib="_environ.vcx" BaseClass="custom" />
	
	PROCEDURE Activate
		IF NOT DODEFAULT()
			RETURN .F.
		ENDIF
		SELECT 0
		
	ENDPROC

	PROCEDURE Init
		LPARAMETERS tlNoShellExecute,tcFileExt
		
		IF NOT DODEFAULT()
			RETURN .F.
		ENDIF
		IF VARTYPE(tlNoShellExecute)=="L"
			this.lShellExecute=(NOT tlNoShellExecute)
		ENDIF
		IF NOT EMPTY(tcFileExt) AND VARTYPE(tcFileExt)=="C"
			this.cFileExt=ALLTRIM(tcFileExt)
		ENDIF
		
	ENDPROC

	PROCEDURE Unload
		RETURN this.cTarget
		
	ENDPROC

	PROCEDURE cboURL.InteractiveChange
		this.parent.cmdOK.Enabled=(NOT EMPTY(this.DisplayValue))
		
	ENDPROC

	PROCEDURE cboURL.ProgrammaticChange
		this.InteractiveChange
		
	ENDPROC

	PROCEDURE cmdCancel.Click
		thisform.Hide
		thisform.Release
		
	ENDPROC

	PROCEDURE cmdOK.Click
		LOCAL lcURL
		
		thisform.Hide
		lcURL=ALLTRIM(this.parent.cboURL.DisplayValue)
		IF NOT EMPTY(lcURL)
			this.parent.cboURL.AddItem(lcURL,1,1)
			lcURL=ALLTRIM(this.parent.cboURL.DisplayValue)
			thisform.cTarget=lcURL
			IF thisform.lShellExecute
				thisform.oShellExecute.ShellExecute(lcURL)
			ENDIF
		ENDIF
		thisform.Release
		
	ENDPROC

	PROCEDURE cmdOpenFile.Click
		LOCAL lcURL
		
		lcURL=LOWER(GETFILE(thisform.cFileExt,"File Name:"))
		IF EMPTY(lcURL)
			RETURN .F.
		ENDIF
		this.parent.cboURL.DisplayValue=lcURL
		this.parent.cmdOK.SetFocus
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _scx2html AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: genhtml		&& Generates HTML calling _GENHTML engine.
		*p: coutfile		&& This is name of HTM file to output.
		*p: cscope		&& The scope of records to process (e.g., NEXT 1, REST).
		*p: csource		&& This is source file from which to generate HTML.
		*p: cstyle		&& The registered style to use for visual display (tables only).
		*p: lautonameoutput		&& Causes _GENHTML to automatically name the output file based on source.
		*p: ngenoutput		&& _GENHTML output options. See _GENHTML file header.
	*</DefinedPropArrayMethod>

	coutfile = 		&& This is name of HTM file to output.
	cscope = 		&& The scope of records to process (e.g., NEXT 1, REST).
	csource = 		&& This is source file from which to generate HTML.
	cstyle = 		&& The registered style to use for visual display (tables only).
	lautonameoutput = .T.		&& Causes _GENHTML to automatically name the output file based on source.
	Name = "_scx2html"
	ngenoutput = 2		&& _GENHTML output options. See _GENHTML file header.
	
	PROCEDURE genhtml		&& Generates HTML calling _GENHTML engine.
		LOCAL lcSource
		
		lcSource = THIS.cSource
		IF VARTYPE(lcSource)#"C" OR !FILE(lcSource)
			lcSource = GETFILE("SCX")
			IF !FILE(lcSource)
				RETURN .F.
			ENDIF
		ENDIF
		
		THIS.cSource = lcSource
		
		IF UPPER(JUSTEXT(lcSource))#"SCX"
			RETURN .F.
		ENDIF
		
		IF VARTYPE(THIS.lAutoNameOutput)="L" AND; 
			THIS.lAutoNameOutput
			THIS.cOutFile = FORCEEXT(lcSource,"HTM")
		ENDIF
		
		DO (_GENHTML) WITH (this.cOutFile),(this.cSource),(this.nGenOutput),"",(this.cStyle),(this.cScope)
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _urlcombobox AS _combobox OF "_base.vcx" 		&& Select URL address combo box.
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: initialize
		*m: navigate		&& Request document based on URL address.
		*m: ohyperlink_access
		*m: openurlhistory
		*m: validurl
		*p: chyperlinkclass
		*p: chyperlinkclasslibrary
		*p: ctempfileprefix
		*p: curl		&& Current URL.
		*p: curlhistorytable		&& Name of URL history table.
		*p: ldropdown
		*p: lformnavigate
		*p: lgotfocus
		*p: linitialized		&& Control initialized flag.
		*p: lmovefocus
		*p: lrequestonenter
		*p: lurlhistory		&& Saves URL history.
		*p: ohyperlink
	*</DefinedPropArrayMethod>

	PROTECTED ldropdown,linitialized
	chyperlinkclass = _HyperLinkBase
	chyperlinkclasslibrary = _HyperLink.vcx
	ColumnCount = 1
	ctempfileprefix = _temp
	curl = 		&& Current URL.
	curlhistorytable = (IIF(VERSION(2)=0,"",HOME())+"URLHstry.dbf")		&& Name of URL history table.
	DisplayCount = 16
	FontName = "MS Sans Serif"
	FontSize = 8
	Format = "K"
	Height = 23
	InputMask = (REPLICATE("X",254))
	lurlhistory = .T.		&& Saves URL history.
	Name = "_urlcombobox"
	ohyperlink = .NULL.
	TabIndex = 2
	Width = 200
	
	PROCEDURE AddItem
		LPARAMETERS tcItem,tnIndex,tnColumn
		LOCAL lcItem,lnLastSelect,ltDateTime,lnCount,lnAtPos,lcTempFilePrefix
		
		IF EMPTY(tcItem)
			NODEFAULT
			RETURN .F.
		ENDIF
		IF TYPE("tnColumn")=="N" AND tnColumn#1
			RETURN
		ENDIF
		ltDateTime=DATETIME()
		lcItem=this.ValidURL(tcItem)
		lnLastSelect=SELECT()
		this.OpenURLHistory
		lnAtPos=RAT("#",lcItem)
		IF lnAtPos>0 AND lnAtPos>RAT("\",lcItem) AND lnAtPos>RAT("/",lcItem)
			NODEFAULT
			SELECT (lnLastSelect)
			RETURN .F.
		ENDIF
		lcTempFilePrefix=LOWER(ALLTRIM(this.cTempFilePrefix))
		IF "."$lcItem AND LOWER(LEFT(JUSTFNAME(lcItem),LEN(lcTempFilePrefix)))==lcTempFilePrefix
			this.DisplayValue=lcItem
			NODEFAULT
			SELECT (lnLastSelect)
			RETURN .F.
		ENDIF
		FOR lnCount = 1 TO this.ListCount
			IF LOWER(ALLTRIM(this.List[lnCount]))==LOWER(lcItem)
				this.RemoveItem(lnCount)
				EXIT
			ENDIF
		ENDFOR
		DODEFAULT(lcItem,tnIndex,tnColumn)
		NODEFAULT
		this.DisplayValue=lcItem
		IF NOT USED("urlhistory")
			SELECT (lnLastSelect)
			RETURN
		ENDIF
		SELECT urlhistory
		IF EOF()
			LOCATE
		ENDIF
		LOCATE FOR ALLTRIM(LOWER(MLINE(URLName,1)))==LOWER(lcItem)
		IF FOUND()
			REPLACE LastAccess WITH ltDateTime, ExecCount WITH ExecCount+1
		ELSE
			INSERT INTO urlhistory (URLName, CreateDate, LastAccess, ExecCount) ;
					VALUES (lcItem, ltDateTime, ltDateTime, 1)
		ENDIF
		SELECT (lnLastSelect)
		
	ENDPROC

	PROCEDURE Destroy
		IF USED("urlhistory")
			USE IN urlhistory
		ENDIF
		
	ENDPROC

	PROCEDURE DropDown
		this.lDropDown=.T.
		
	ENDPROC

	PROCEDURE GotFocus
		this.lDropDown=.F.
		this.lMoveFocus=.F.
		IF this.lGotFocus
			RETURN
		ENDIF
		IF EMPTY(this.DisplayValue)
			this.SelStart=0
			this.SelLength=0
		ELSE
			this.SelStart=0
			this.SelLength=LEN(this.DisplayValue)
		ENDIF
		
	ENDPROC

	PROCEDURE initialize
		IF this.lInitialized
			RETURN
		ENDIF
		this.lInitialized=.T.
		IF NOT this.OpenURLHistory()
			SELECT 0
			RETURN .F.
		ENDIF
		IF USED("urlhistory")
			SELECT urlhistory
			SCAN ALL
				this.AddItem(URLName,1,1.1)
			ENDSCAN
		ENDIF
		SELECT 0
		
	ENDPROC

	PROCEDURE KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		this.lGotFocus=.T.
		IF this.lRequestOnEnter AND nKeyCode=13
			IF this.lDropDown
				this.lDropDown=.F.
				KEYBOARD "{TAB}" PLAIN
			ENDIF
			this.Valid
		ENDIF
		
	ENDPROC

	PROCEDURE LostFocus
		this.lGotFocus=.F.
		this.lDropDown=.F.
		
	ENDPROC

	PROCEDURE MouseUp
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		IF this.lGotFocus
			RETURN
		ENDIF
		this.lGotFocus=.T.
		IF this.SelLength>0
			RETURN
		ENDIF
		IF EMPTY(this.DisplayValue)
			this.SelStart=0
			this.SelLength=0
		ELSE
			this.SelStart=0
			this.SelLength=LEN(this.DisplayValue)
		ENDIF
		
	ENDPROC

	PROCEDURE navigate		&& Request document based on URL address.
		LOCAL lcURL,lcTempFilePrefix
		
		IF this.lDropDown
			lcURL=ALLTRIM(this.Value)
		ELSE
			lcURL=ALLTRIM(this.DisplayValue)
		ENDIF
		this.lDropDown=.F.
		IF EMPTY(lcURL)
			RETURN .F.
		ENDIF
		lcTempFilePrefix=LOWER(ALLTRIM(this.cTempFilePrefix))
		IF "."$lcURL AND LOWER(LEFT(JUSTFNAME(lcURL),LEN(lcTempFilePrefix)))==lcTempFilePrefix
			this.DisplayValue=lcURL
			RETURN .F.
		ENDIF
		IF LOWER(lcURL)==LOWER(this.cURL)
			RETURN
		ENDIF
		IF SUBSTR(PADR(lcURL,5),5,1)==":" AND (LOWER(lcURL)==LOWER("file://"+this.cURL) OR ;
				LOWER(lcURL)==LOWER("http://"+this.cURL))
			RETURN
		ENDIF
		this.AddItem(lcURL,1,1)
		IF NOT this.lFormNavigate
			this.oHyperLink.NavigateTo(lcURL)
			RETURN
		ENDIF
		IF NOT this.lFormNavigate OR TYPE("thisform")#"O" OR ;
				NOT LOWER(PEMSTATUS(thisform,"Navigate",3))=="method"
			RETURN
		ENDIF
		thisform.Navigate(lcURL)
		
	ENDPROC

	PROCEDURE ohyperlink_access
		IF VARTYPE(this.oHyperlink)#"O"
			this.SetObjectRef("oHyperLink",this.cHyperLinkClass,this.cHyperLinkClassLibrary)
		ENDIF
		RETURN this.oHyperlink
		
	ENDPROC

	PROCEDURE openurlhistory
		LOCAL lcFileName,lnLastSelect
		
		IF NOT this.lURLHistory OR EMPTY(this.cURLHistoryTable)
			IF USED("urlhistory")
				USE IN urlhistory
			ENDIF
			RETURN .F.
		ENDIF
		lnLastSelect=SELECT()
		IF USED("urlhistory")
			SELECT urlhistory
		ELSE
			lcFileName=LOWER(FULLPATH(this.cURLHistoryTable))
			SELECT 0
			IF NOT EMPTY(SYS(2000,lcFileName))
				USE (lcFileName) SHARED ALIAS urlhistory AGAIN
				IF NOT USED()
					SELECT (lnLastSelect)
					RETURN .F.
				ENDIF
				IF TYPE("URLName")#"M"
					USE
					ERASE (lcFileName)
				ENDIF
			ENDIF
			IF EMPTY(SYS(2000,lcFileName))
				CREATE TABLE (lcFileName) ;
						(URLName M, CreateDate T, LastAccess T, ExecCount N(8))
				USE (lcFileName) SHARED ALIAS urlhistory AGAIN
			ENDIF
			IF TYPE("CreateDate")#"T" OR TYPE("LastAccess")#"T" OR TYPE("ExecCount")#"N"
				USE (lcFileName) EXCLUSIVE ALIAS urlhistory
				IF NOT USED()
					SELECT (lnLastSelect)
					RETURN .F.
				ENDIF
				IF TYPE("CreateDate")#"T"
					ZAP
					ALTER TABLE (lcFileName) ADD COLUMN CreateDate T NULL
				ENDIF
				IF TYPE("LastAccess")#"T"
					ALTER TABLE (lcFileName) ADD COLUMN LastAccess T NULL
				ENDIF
				IF TYPE("ExecCount")#"N"
					ALTER TABLE (lcFileName) ADD COLUMN ExecCount N(8) NULL
				ENDIF
				USE (lcFileName) SHARED ALIAS urlhistory AGAIN
			ENDIF
			IF KEY(1)=="LASTACCESS"
				SET ORDER TO LastAccess
			ELSE
				INDEX ON LastAccess TAG LastAccess ASCENDING ADDITIVE
			ENDIF
			SET FILTER TO NOT DELETED()
			LOCATE
		ENDIF
		
	ENDPROC

	PROCEDURE ProgrammaticChange
		this.cURL=this.DisplayValue
		
	ENDPROC

	PROCEDURE Refresh
		this.Initialize
		
	ENDPROC

	PROCEDURE Valid
		LOCAL llDropDown
		
		llDropDown=this.lDropDown
		IF this.lRequestOnEnter AND NOT this.lMoveFocus
			this.Navigate
		ENDIF
		IF llDropDown
			this.lMoveFocus=.T.
			IF this.lRequestOnEnter
				KEYBOARD "{TAB}" PLAIN
			ELSE
				KEYBOARD "{Ctrl+A}" PLAIN
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE validurl
		LPARAMETERS tcURL
		LOCAL lcURL
		
		IF EMPTY(tcURL)
			RETURN ""
		ENDIF
		lcURL=ALLTRIM(tcURL)
		IF NOT ":"$lcURL AND NOT LOWER(LEFT(lcURL,5))=="http:" AND ;
				NOT LOWER(LEFT(lcURL,5))=="file:" AND ;
				NOT LOWER(LEFT(lcURL,4))=="ftp." AND (LOWER(LEFT(lcURL,4))=="www." OR ;
				INLIST(LOWER(RIGHT(lcURL,4)),".com",".gov",".net") OR ;
				(NOT SUBSTR(lcURL,2,1)==":" AND NOT LEFT(lcURL,2)=="\\"))
			lcURL="http://"+lcURL
		ENDIF
		IF SUBSTR(PADR(lcURL,5),5,1)==":"
			lcURL=STRTRAN(STRTRAN(lcURl,"\","/"),"///","//")
		ELSE
			IF (NOT ":"$lcURL OR AT(":",lcURL)=2) AND NOT LOWER(LEFT(lcURL,4))=="ftp."
				lcURL="file://"+STRTRAN(STRTRAN(STRTRAN(lcURL,"\","/"),"///","//"),"//","/")
			ENDIF
		ENDIF
		RETURN lcURL
		
	ENDPROC

	PROCEDURE When
		IF this.lMoveFocus
			this.lMoveFocus=.F.
			RETURN .F.
		ENDIF
		
	ENDPROC

ENDDEFINE
