*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="_utility.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS _arraylib AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: acolscan		&& Scans an array limited to a particular column.
		*m: delaitem		&& Deletes and array element.
		*m: insaitem		&& Inserts and array element.
	*</DefinedPropArrayMethod>

	Name = "_arraylib"
	
	PROCEDURE acolscan		&& Scans an array limited to a particular column.
		* This function does an ASCAN for a specific row
		* aSearch - array to scan
		* sExpr - expression to scan
		* nColumn - column to scan
		* lRetRow - return row (T) or array element (F)
		LPARAMETER aSearch,sExpr,nColumn,lRetRow
		LOCAL npos
		IF VARTYPE(m.nColumn)#'N'
			nColumn = 1
		ENDIF
		IF VARTYPE(m.lRetRow)#'L'
			lRetRow = .F.
		ENDIF
		
		npos = 1
		DO WHILE .T.
			npos = ASCAN(aSearch,m.sExpr,m.npos)
			DO CASE
			CASE m.npos=0	&&did not find match
				EXIT
			CASE ASUBSCRIPT(aSearch,m.npos,2)=m.nColumn
				EXIT
			OTHERWISE
				m.npos=m.npos+1
			ENDCASE
		ENDDO
		IF m.lRetRow
			RETURN ASUBSCRIPT(aSearch,m.npos,1)
		ELSE
			RETURN m.npos
		ENDIF
		
	ENDPROC

	PROCEDURE delaitem		&& Deletes and array element.
		* Generic routine to delete an array element. If the array is
		* multi-dimensional, then a whole row is deleted.
		*
		* aArray- array to scan
		* wziRow - row to delete
		LPARAMETERS aArray,wziRow
		
		LOCAL nColumns
		IF ALEN(aArray,1)<m.wziRow OR m.wziRow<0
			RETURN
		ENDIF
		IF ALEN(aArray,1)=1
			STORE ""  TO aArray
		ELSE
			nColumns = ALEN(aArray,2)
			ADEL(aArray,m.wziRow)
			IF nColumns=0
				DIMENSION aArray[ALEN(aArray)-1]
			ELSE
				DIMENSION aArray[ALEN(aArray,1)-1,nColumns]
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE insaitem		&& Inserts and array element.
		* Inserts an array element into an array.
		*
		* aArray - array name
		* sContents - contents to insert
		* iRow - row to insert into
		* lSetAll - whether to set all elements in row for multi-dime array
		
		LPARAMETER aArray,sContents,iRow,lSetAll
		LOCAL nColumns, i
		
		IF VARTYPE(iRow) # "N"
			iRow = ALEN(aArray)
		ENDIF
		
		nColumns = ALEN(aArray,2)
		DO CASE
		CASE iRow<0
			RETURN
		CASE ALEN(aArray)=1 AND EMPTY(aArray[1])
			aArray[1]=m.sContents
		CASE nColumns = 0
			iRow = MIN(iRow,ALEN(aArray))
			DIMENSION aArray[ALEN(aArray)+1]
			IF iRow # ALEN(aArray)-1
				AINS(aArray,m.iRow+1)	
			ENDIF
			aArray[m.iRow+1]=m.sContents
		OTHERWISE
			iRow = MIN(iRow,ALEN(aArray,1))
			DIMENSION aArray[ALEN(aArray,1)+1,nColumns]	
			IF iRow # ALEN(aArray,1)-1
				AINS(aArray,m.iRow+1)
			ENDIF
			IF !lSetAll
				aArray[m.iRow+1,1]=m.sContents
			ELSE
				FOR i = 1 TO nColumns
					aArray[m.iRow+1,i]=m.sContents	
				ENDFOR
			ENDIF
		ENDCASE
	ENDPROC

ENDDEFINE

DEFINE CLASS _filer AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "_utility.h"
	*<DefinedPropArrayMethod>
		*m: csearchpath_access
		*m: find		&& Runs search for files based on criteria.
		*p: cfileexpression		&& File skeleton for searching. Can include wildcards such as ? and *.
		*p: csearchpath		&& The folder path to begin searching for files.
		*p: csearchtext		&& Text string to search for within files.
		*p: lignorecase		&& Whether to ignore case during search.
		*p: lpromptdir		&& Whether to prompt the user for search path if none entered.
		*p: lsubfolder		&& Whether to search in subfolders for files.
		*p: lwholewords		&& Whether to search for whole word matches.
		*p: ofiles		&& Collection of files returned by Find search.
	*</DefinedPropArrayMethod>

	cfileexpression = 		&& File skeleton for searching. Can include wildcards such as ? and *.
	csearchpath = 		&& The folder path to begin searching for files.
	csearchtext = 		&& Text string to search for within files.
	lignorecase = .T.		&& Whether to ignore case during search.
	lpromptdir = .T.		&& Whether to prompt the user for search path if none entered.
	lsubfolder = .T.		&& Whether to search in subfolders for files.
	Name = "_filer"
	
	PROCEDURE csearchpath_access
		*To do: Modify this routine for the Access method
		IF EMPTY(THIS.cSearchPath)
			IF THIS.lPromptDir
				THIS.cSearchPath = GETDIR()
			ENDIF
			IF EMPTY(THIS.cSearchPath)
				THIS.cSearchPath = FULLPATH(CURDIR())
			ENDIF
		ENDIF
		RETURN THIS.cSearchPath
		
	ENDPROC

	PROCEDURE Destroy
		THIS.oFiles = .NULL.
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		LOCAL cFilerFile
		
		* Check to make sure library is registered
		IF INLIST(nError,1426,1733)
			DO CASE
			CASE FILE(HOME()+C_FILERDLL)
				cFilerFile = HOME()+C_FILERDLL
			CASE FILE(HOME()+C_FILERPATH+C_FILERDLL)
				cFilerFile = HOME()+C_FILERPATH+C_FILERDLL
			CASE FILE(C_FILERDLL)
				cFilerFile = C_FILERDLL
			OTHERWISE
				MESSAGEBOX(ERR_NOFILERDLL_LOC,48)
				RETURN
			ENDCASE
			
			IF MESSAGEBOX(MSG_REGFILERDLL_LOC,36)=6
					RUN /n REGSVR32 /s &cFilerFile
				RETRY
			ELSE
				RETURN	
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE find		&& Runs search for files based on criteria.
		*!*	Filer PEMS
		*!* =================
		*!*	SearchPath
		*!*	FileExpression
		*!*	SubFolder
		*!*	SearchText1,SearchText2,SearchText3
		*!*	IgnoreCase
		*!*	WholeWords
		*!*	SearchAnd
		*!*	Find
		*!*	DoSearch
		*!*	Files (collection)
		
		*!*	Files Collection PEMS
		*!* =====================
		*!*	Item
		*!*	Count
		*!*	Edit
		
		*!*	File Object PEMS
		*!* =================
		*!*	Name
		*!*	Size
		*!*	SizeHigh
		*!*	Attr
		*!*	DateTime
		*!*	LastAccessTime
		*!*	LastWriteTime
		*!*	AlternateName
		*!*	Path
		*!*	Edit
		*!*	Delete
		
		
		LOCAL oFiler,nFiles
		
		oFiler = CreateObject(C_FILERCLASS)
		IF TYPE("oFiler")#"O" OR ISNULL(oFiler)
			MESSAGEBOX(ERR_NOCLASS_LOC)
			RETURN
		ENDIF
		
		oFiler.fileexpression = IIF(EMPTY(THIS.cFileExpression),"*.*",THIS.cFileExpression)
		oFiler.searchpath = THIS.cSearchPath
		oFiler.subfolder = THIS.lsubfolder
		
		IF !EMPTY(THIS.cSearchText)
			oFiler.SearchText1 = THIS.cSearchText
		ENDIF
		oFiler.WholeWords = THIS.lWholeWords
		oFiler.IgnoreCase = THIS.lIgnoreCase
		
		THIS.oFiles = null
		nFiles = oFiler.find(1)
		
		IF nFiles # 0
			THIS.oFiles = oFiler.Files
		ENDIF
		RETURN m.nFiles
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _fileversion AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "_utility.h"
	*<DefinedPropArrayMethod>
		*m: cfilename_access
		*m: displayversion		&& Displays version information for cFileName.
		*m: getversion		&& Retrieves version information for cFileName.
		*p: cfilename		&& Name of file to get information.
		*a: aversion[12,0]		&& Array of file version information.
	*</DefinedPropArrayMethod>

	Name = "_fileversion"
	
	PROCEDURE cfilename_access
		*To do: Modify this routine for the Access method
		IF TYPE("THIS.cFilename")#"C" OR EMPTY(THIS.cFilename) OR !FILE(THIS.cFilename)
			THIS.cFilename = GETFILE()
			IF TYPE("THIS.cFilename")#"C" OR EMPTY(THIS.cFilename) OR !FILE(THIS.cFilename)
				THIS.cFilename = ""
			ENDIF
		ENDIF
		RETURN THIS.cfilename
		
	ENDPROC

	PROCEDURE displayversion		&& Displays version information for cFileName.
		*File Version Strings
		
		LOCAL cVerString
		cVerString = ""
		
		IF NOT EMPTY(THIS.aVersion(1))
			cVerString =  FILEVER_COMMENT_LOC + ALLT(THIS.aVersion(1))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(2))
			cVerString = m.cVerString+CRLF+FILEVER_COMPANY_LOC+ ALLT(THIS.aVersion(2))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(3))
			cVerString =  m.cVerString+CRLF+FILEVER_FILEDESC_LOC+ ALLT(THIS.aVersion(3))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(4))
			cVerString = m.cVerString+CRLF+FILEVER_FILEVER_LOC+ ALLT(THIS.aVersion(4))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(5))
			cVerString = m.cVerString+CRLF+FILEVER_INTERNAL_LOC+ ALLT(THIS.aVersion(5))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(6))
			cVerString = m.cVerString+CRLF+FILEVER_COPYRIGHT_LOC+ ALLT(THIS.aVersion(6))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(7))
			cVerString = m.cVerString+CRLF+FILEVER_TRADMARK_LOC+ ALLT(THIS.aVersion(7))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(8))
			cVerString = m.cVerString+CRLF+FILEVER_FILENAME_LOC+ ALLT(THIS.aVersion(8))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(9))
			cVerString = m.cVerString+CRLF+FILEVER_PRIVATE_LOC+ ALLT(THIS.aVersion(9))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(10))
			cVerString = m.cVerString+CRLF+FILEVER_PRODUCTNAME_LOC+ ALLT(THIS.aVersion(10))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(11))
			cVerString = m.cVerString+CRLF+FILEVER_PRODUCTVER_LOC+ ALLT(THIS.aVersion(11))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(12))
			cVerString = m.cVerString+CRLF+FILEVER_SPECIAL_LOC+ ALLT(THIS.aVersion(12))
		ENDIF
		IF NOT EMPTY(THIS.aVersion(14))
			cVerString = m.cVerString+CRLF+FILEVER_LANGUAGE_LOC+ ALLT(THIS.aVersion(14))
		ENDIF
		
		IF EMPTY(m.cVerString) OR TYPE("THIS.aVersion[1]")="L"
			cVerString = FILEVER_NOVERSION_LOC
		ENDIF
		
		MESSAGEBOX(m.cVerString,MSG_FILEVERSION_LOC+THIS.cFileName)
		
	ENDPROC

	PROCEDURE getversion		&& Retrieves version information for cFileName.
		LOCAL aVerArray, nError
		IF FILE(THIS.cFileName)
			DIMENSION aVerarray[1]
			DIMENSION THIS.aVersion[15]
			STORE "" TO THIS.aVersion
			nError = AGetFileVersion(aVerArray,THIS.cFileName)
			IF m.nError # 0
				ACOPY(aVerArray,THIS.aVersion)
				RETURN .T.
			ENDIF
		ENDIF
		RETURN .F.
		
	ENDPROC

	PROCEDURE Init
		DIMENSION THIS.aVersion[15]
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _graphbyrecord AS _container OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="Autograph" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="oleGraph" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="_nav4buttons" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cboChartType" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkPlotBy" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="chkShowLegend" UniqueID="" Timestamp="" />

	#INCLUDE "_utility.h"
	*<DefinedPropArrayMethod>
		*m: laddlegend_assign
		*m: lseriesbyrow_assign
		*m: ncharttype_assign
		*m: refreshgraph		&& Refreshes graph when record pointer moved.
		*m: setcharttype		&& Sets the chart type.
		*m: setupgraph		&& Initializes graph controls.
		*p: ccharttype
		*p: cgraphfield		&& Field to use for caption.
		*p: cgraphtitle		&& Caption for record label.
		*p: laddlegend		&& Whether to add a legend.
		*p: lseriesbyrow		&& Whether to plot series by column or row.
		*p: ncharttype		&& Chart type (numeric value).
		*a: adatafields[1,0]		&& Array of data fields to graph.
	*</DefinedPropArrayMethod>

	BorderWidth = 0
	ccharttype = 
	cgraphfield = 		&& Field to use for caption.
	cgraphtitle = Record: 		&& Caption for record label.
	Height = 270
	laddlegend = .T.		&& Whether to add a legend.
	lseriesbyrow = .T.		&& Whether to plot series by column or row.
	Name = "_graphbyrecord"
	ncharttype = 78		&& Chart type (numeric value).
	Width = 302

	ADD OBJECT '_nav4buttons' AS _nav4buttons WITH ;
		Left = 7, ;
		Name = "_nav4buttons", ;
		TabIndex = 1, ;
		Top = 206, ;
		cmdBottom.Name = "cmdBottom", ;
		cmdBottom.TabIndex = 3, ;
		cmdTop.Name = "cmdTop", ;
		cmdTop.TabIndex = 1, ;
		cmgNav.BorderStyle = 0, ;
		cmgNav.Command1.Left = 33, ;
		cmgNav.Command1.Name = "Command1", ;
		cmgNav.Command1.Top = 5, ;
		cmgNav.Command2.Left = 60, ;
		cmgNav.Command2.Name = "Command2", ;
		cmgNav.Command2.Top = 5, ;
		cmgNav.Name = "cmgNav", ;
		cmgNav.TabIndex = 2, ;
		cusTableNav.Name = "cusTableNav"
		*< END OBJECT: ClassLib="_table.vcx" BaseClass="container" />

	ADD OBJECT 'Autograph' AS autograph WITH ;
		Height = 17, ;
		Left = 252, ;
		naction = 0, ;
		Name = "Autograph", ;
		Top = 252, ;
		Width = 24
		*< END OBJECT: ClassLib="autgraph.vcx" BaseClass="custom" />

	ADD OBJECT 'cboChartType' AS _combobox WITH ;
		Height = 24, ;
		Left = 192, ;
		Name = "cboChartType", ;
		Style = 2, ;
		TabIndex = 2, ;
		Top = 211, ;
		Width = 90
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="combobox" />

	ADD OBJECT 'chkPlotBy' AS _checkbox WITH ;
		BackStyle = 0, ;
		Caption = "\<Plot by row", ;
		Height = 17, ;
		Left = 160, ;
		Name = "chkPlotBy", ;
		TabIndex = 4, ;
		Top = 248, ;
		Width = 84
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="checkbox" />

	ADD OBJECT 'chkShowLegend' AS _checkbox WITH ;
		BackStyle = 0, ;
		Caption = "\<Show legend", ;
		Height = 17, ;
		Left = 19, ;
		Name = "chkShowLegend", ;
		TabIndex = 3, ;
		Top = 248, ;
		Width = 90
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="checkbox" />

	ADD OBJECT 'Label1' AS label WITH ;
		BackStyle = 0, ;
		Caption = "\<Type:", ;
		Height = 17, ;
		Left = 160, ;
		Name = "Label1", ;
		TabIndex = 6, ;
		Top = 217, ;
		Width = 31
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'oleGraph' AS olecontrol WITH ;
		Height = 184, ;
		Left = 12, ;
		Name = "oleGraph", ;
		TabIndex = 5, ;
		Top = 7, ;
		Visible = .F., ;
		Width = 279
		*< END OBJECT: BaseClass="olecontrol" OLEObject="" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9////BAAAAP7///8FAAAA/v///wYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAP7//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8EAAAAAwgCAAAAAADAAAAAAAAARgAAAAAAAAAAAAAAAFD2pkSTEb4BAwAAAIAVAAAAAAAAAQBPAGwAZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoAAgH/////BQAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAA4AAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIBBgAAAAIAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAQAAAAAAAAA/v////7////+////BAAAAP7///8GAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACMAAAAkAAAAJQAAACYAAAAnAAAA/v///ykAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAMQAAADIAAAAzAAAANAAAADUAAAA2AAAANwAAADgAAAA5AAAAOgAAADsAAAA8AAAAPQAAAD4AAAA/AAAAQAAAAEEAAABCAAAAQwAAAEQAAABFAAAARgAAAEcAAABIAAAASQAAAEoAAABLAAAATAAAAE0AAABOAAAATwAAAFAAAABRAAAAUgAAAFMAAABUAAAAVQAAAP7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8BAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAP7/AwoAAP////8DCAIAAAAAAMAAAAAAAABGEwAAAE1pY3Jvc29mdCBHcmFwaCA5NwAHAAAAR0JpZmY1ABAAAABNU0dyYXBoLkNoYXJ0LjgA9DmycQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkIEACABgUAuA3MB0EAAAAGAAAAQgACALAEIgACAAAAHgQcAAUAFwAAIiQiIywjIzBfKTtcKCIkIiMsIyMwXCkeBCEABgAcAAAiJCIjLCMjMF8pO1tSZWRdXCgiJCIjLCMjMFwpHgQiAAcAHQAAIiQiIywjIzAuMDBfKTtcKCIkIiMsIyMwLjAwXCkeBCcACAAiAAAiJCIjLCMjMC4wMF8pO1tSZWRdXCgiJCIjLCMjMC4wMFwpHgQ3ACoAMgAAX1cAbwByAGsAYgBvAG8AawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAIBAQAAAAMAAAD/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAI4IAAAAAAAAAQBDAG8AbQBwAE8AYgBqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAgD///////////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAYgAAAAAAAAACAE8AbABlAFAAcgBlAHMAMAAwADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgAAABeCwAAAAAAAAEATwBsAGUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKAAAA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/v///wAAAAAAAAAAKCIkIiogIywjIzBfKTtfKCIkIiogXCgjLCMjMFwpO18oIiQiKiAiLSJfKTtfKEBfKR4ELgApACkAAF8oKiAjLCMjMF8pO18oKiBcKCMsIyMwXCk7XygqICItIl8pO18oQF8pHgQ/ACwAOgAAXygiJCIqICMsIyMwLjAwXyk7XygiJCIqIFwoIywjIzAuMDBcKTtfKCIkIiogIi0iPz9fKTtfKEBfKR4ENgArADEAAF8oKiAjLCMjMC4wMF8pO18oKiBcKCMsIyMwLjAwXCk7XygqICItIj8/Xyk7XyhAXykxABoAoAABAP9/vAIAAAAAAAAFAUEAcgBpAGEAbAAxABoAoAABAP9/vAIAAAAAAAAFAUEAcgBpAGEAbAAxABoAyAABAP9/vAIAAAAAAAAFAUEAcgBpAGEAbAA9ABIApv+J/usU5AwAACwjIzAuMDBfhQAIACACAAAAAgAACgAAAAkIEACABgCAuA3MB0EAAAAGAAAAYBAKAEoQqgqgAAAAAABgEAoAShCqCqAAAQABAKwCAgA4AJIA4gA4AAAAAAD///8A/wAAAAD/AAAAAP8A//8AAP8A/wAA//8AgAAAAACAAAAAAIAAgIAAAIAAgAAAgIAAwMDAAICAgACZmf8AmTNmAP//zADM//8AZgBmAP+AgAAAZswAzMz/AAAAgAD/AP8A//8AAAD//wCAAIAAgAAAAACAgAAAAP8AAMz/AMz//wDM/8wA//+ZAJnM/wD/mcwAzJn/AP/MmQAzZv8AM8zMAJnMAAD/zAAA/5kAAP9mAABmZpkAlpaWAAAzZgAzmWYAADMAADMzAACZMwAAmTNmADMzmQAzMzMAXBAOAAMAAAAAAMjg2AAAAAAAUhAEAAECEAAzEAAAjAAEAAEAAQAmEAIAAgBTEAQAAAAEAFQQAABVEAYAAQAAAAABVxABAAFZEAgAZAUoBSgjFRg9AAoAlgDQEVwcjggAAD4ADgABAQEAAQEAAQABAAAAAFgQAgAAAB0AEQADAAAAAAAAAQAAAJ8PAAAEADQQAAABEAIAAAACEBAAAAAAAAAAAAAAwAIBAMCNADMQAACgAAQAAQABAGQQCAAAAAEAAAABAAMQDAABAAEAAAAAAAEAAAAzEAAAURAIAAABAgAAAAEAURAIAAEBAgAAAAEAURAIAAIBAgAAAAAAURAIAAMBAgAAAAAABhAIAP//AAAAAAAAMxAAAF8QAgAAADQQAABFEAIAAAA0EAAAAxAMAAEAAQAAAAAAAQAAADMQAABREAgAAAECAAAAAgBREAgAAQECAAAAAgBREAgAAgECAAAAAABREAgAAwECAAAAAAAGEAgA//8BAAEAAAAzEAAAXxACAAAANBAAAEUQAgAAADQQAAADEAwAAQABAAAAAAABAAAAMxAAAFEQCAAAAQIAAAADAFEQCAABAQIAAAADAFEQCAACAQIAAAAAAFEQCAADAQIAAAAAAAYQCAD//wIAAgAAADMQAABfEAIAAAA0EAAARRACAAAANBAAAEQQBAAJAAAAJBACAAIAJRAgAAICAQAAAAAAxP///5D///8AAAAAAAAAALEATQAgEAAAMxAAAE8QFAACAAIAAAAAAAAAAAAAAAAAAAAAACYQAgAAAFEQCAAAAQIAAAAAADQQAAAkEAIAAwAlECAAAgIBAAAAAADE////kP///wAAAAAAAAAAsQBNACAQAAAzEAAATxAUAAIAAgAAAAAAAAAAAAAAAAAAAAAAJhACAAEAURAIAAABAgAAAAAANBAAAEYQAgABAEEQEgAAAHcAAADfAAAAnw0AAOENAAAzEAAATxAUAAIAAgB3AAAA3wAAAJ8NAADhDQAAHRASAAAAAAAAAAAAAAAAAAAAAAAAADMQAAAgEAgAAQABAAEAAQBiEBIAAAAAAAEAAAABAAAAAAAAAO8AHhAeAAIAAQEAAAAAAAAAAAAAAAAAAAAAAAAAACMATQAAACEQAgADAAcQDACAgIAAAAAAAAAAFwAKEBAAwMDAAAAAAAABAAAAFgBPADQQAAAdEBIAAQAAAAAAAAAAAAAAAAAAAAAAMxAAAB8QKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHwEeEB4AAgADAQAAAAAAAAAAAAAAAAAAAAAAAAAAIwBNAAAAIRACAAEABxAMAAAAAAAAAAAACQBNACEQAgADAAcQDAAAAAAAAAAAAAkATQAKEBAAAAAAAMjg2AABAAEATQBOADQQAAAUEBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAzEAAAFxAGAAAAlgAAACIQCgAAAAAAAAAAAA8AOhAOABQADwAeAGQAZAAAABYAFRAUAJkOAABpBQAA1wAAALcEAAADAR8AMxAAAE8QFAAFAAIAmQ4AAGkFAAAAAAAAAAAAACUQIAACAgEAAAAAAMT///+Q////AAAAAAAAAACxAE0AAAAAADMQAABPEBQAAgACAAAAAAAAAAAAAAAAAAAAAABREAgAAAECAAAAAAA0EAAAMhAEAAAAAwAzEAAABxAMAAAAAAAAAAAACQBNAAoQEADI4NgAAAAAAAAAAABOAE0ANBAAADQQAAA0EAAANBAAADQQAAAAAg4AAAAAAAAAAAAAAAMAAAAKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/////AwAAAAQAAAABAAAA/////wIAAAAAAAAAqCMAAIkTAAA2CwAAAQAJAAADmwUAAAgABQIAAAAABQAAAAkCAAAAAAUAAAABAsjg2AAEAAAABAENAAQAAAACAQIABQAAAAwCvQBZAQMAAAAeAAQAAAAnAf//BQIAAPcAAAMAAQAAAACAAAAAAIAAAICAAAAAAIAAgACAAACAgADAwMAASJCIAIjAuAAEBAQECAgIBAwMDAQREREEFhYWBBwcHAQiIiIEKSkpBFVVVQRNTU0EQkJCBDk5OQT/fIAE/1BQBNYAkwTM7P8E79bGBOfn1gStqZAEMwAABGYAAASZAAAEzAAABAAzAAQzMwAEZjMABJkzAATMMwAE/zMABABmAAQzZgAEZmYABJlmAATMZgAE/2YABACZAAQzmQAEZpkABJmZAATMmQAE/5kABADMAAQzzAAEZswABJnMAATMzAAE/8wABGb/AASZ/wAEzP8ABAAAMwQzADMEZgAzBJkAMwTMADME/wAzBAAzMwQzMzMEZjMzBJkzMwTMMzME/zMzBABmMwQzZjMEZmYzBJlmMwTMZjME/2YzBACZMwQzmTMEZpkzBJmZMwTMmTME/5kzBADMMwQzzDMEZswzBJnMMwTMzDME/8wzBDP/MwRm/zMEmf8zBMz/MwT//zMEAABmBDMAZgRmAGYEmQBmBMwAZgT/AGYEADNmBDMzZgRmM2YEmTNmBMwzZgT/M2YEAGZmBDNmZgRmZmYEmWZmBMxmZgQAmWYEM5lmBGaZZgSZmWYEzJlmBP+ZZgQAzGYEM8xmBJnMZgTMzGYE/8xmBAD/ZgQz/2YEmf9mBMz/ZgT/AMwEzAD/BACZmQSZM5kEmQCZBMwAmQQAAJkEMzOZBGYAmQTMM5kE/wCZBABmmQQzZpkEZjOZBJlmmQTMZpkE/zOZBDOZmQRmmZkEmZmZBMyZmQT/mZkEAMyZBDPMmQRmzGYEmcyZBMzMmQT/zJkEAP+ZBDP/mQRmzJkEmf+ZBMz/mQT//5kEAADMBDMAmQRmAMwEmQDMBMwAzAQAM5kEMzPMBGYzzASZM8wEzDPMBP8zzAQAZswEM2bMBGZmmQSZZswEzGbMBP9mmQQAmcwEM5nMBGaZzASZmcwEzJnMBP+ZzAQAzMwEM8zMBGbMzASZzMwEzMzMBP/MzAQA/8wEM//MBGb/mQSZ/8wEzP/MBP//zAQzAMwEZgD/BJkA/wQAM8wEMzP/BGYz/wSZM/8EzDP/BP8z/wQAZv8EM2b/BGZmzASZZv8EzGb/BP9mzAQAmf8EM5n/BGaZ/wSZmf8EzJn/BP+Z/wQAzP8EM8z/BGbM/wSZzP8EzMz/BP/M/wQz//8EZv/MBJn//wTM//8E/2ZmBGb/ZgT//2YEZmb/BP9m/wRm//8EpQAhBF9fXwR3d3cEhoaGBJaWlgTLy8sEsrKyBNfX1wTd3d0E4+PjBOrq6gTx8fEE+Pj4BMjg2ACgoKQAgICAAP8AAAAA/wAA//8AAAAA/wD/AP8AAP//AP///wAEAAAANAIAAAMAAAA1AAMAAAAeAAQAAAAnAf//BQAAAAsCAAAAAAMAAAAeAAUAAAABAsjg2AAFAAAACQIAAAAAEAAAAPsC9f8AAAAAAAC8AgAAAAAAAAAiQXJpYWwAAKAEAAAALQEBAAQAAAAtAQEAEAAAAPsCEAAHAAAAAAC8AgAAAAABAgIiU3lzdGVtAG4EAAAALQECAAQAAAAnAf//AwAAAB4ABAAAAC0BAQAFAAAAAQLI4NgABQAAAAkCAAAAAAcAAAAWBL0AWQEAAAAABAAAAC0BAgAEAAAAJwH//wMAAAAeAAQAAAAtAQEABQAAAAECyODYAAUAAAAJAgAAAAAHAAAAFgS9AFkBAAAAAAQAAAAtAQIABAAAACcB//8DAAAAHgAEAAAALQEBAAUAAAABAsjg2AAFAAAACQIAAAAABwAAABYEuQBVAQQABAAEAAAALQECAAQAAAAnAf//AwAAAB4ABAAAAC0BAQAFAAAAAQLI4NgABQAAAAkCAAAAAAcAAAAWBL0AWQEAAAAACQAAAPoCAAABAAAAAAAAACIABAAAAC0BAwAHAAAA/AIBAAAAAACAIAQAAAAtAQQABQAAAAECyODYAgQAAAAEAQ0ABAAAAAIBAgAHAAAAGwR6AFABQwA+AQkAAAD6AgAAAAAAAAAAAAAiAAQAAAAtAQUABwAAAPwCAAD///8AAAAEAAAALQEGAAQAAAAtAQIABAAAACcB//8DAAAAHgAEAAAALQEBAAQAAAAtAQQABAAAAC0BAwAFAAAAAQLI4NgCBQAAAAkCAAAAAAcAAAAWBHkAUAFDAD4BBAAAAC0BBQAEAAAALQEGAAQAAAAtAQIABAAAACcB//8DAAAAHgAEAAAALQEBAAQAAAAtAQQABAAAAC0BAwAFAAAAAQLI4NgCBQAAAAkCAAAAAAcAAAAWBHkAUAFDAD4BCQAAAPoCAAABAAAAAAAAACIABAAAAC0BBwAEAAAA8AEDAAcAAAD8AgAAmZn/AoAgBAAAAC0BAwAEAAAA8AEEAAUAAAAJAsz/zAIFAAAAAQKZmf8CBAAAAAQBDQAEAAAAAgECAAcAAAAbBFEASQFKAEIBBAAAAC0BBQAEAAAALQEGAAQAAAAtAQIABAAAACcB//8DAAAAHgAEAAAALQEBAAQAAAAtAQMABAAAAC0BBwAFAAAAAQKZmf8CBQAAAAkCzP/MAgcAAAAWBHkAUAFDAD4BBAAAAC0BBQAEAAAALQEGAAQAAAAtAQIABAAAACcB//8DAAAAHgAEAAAALQEBAAQAAAAtAQMABAAAAC0BBwAFAAAAAQKZmf8CBQAAAAkCzP/MAgcAAAAWBHkAUAFDAD4BCQAAAPoCAAABAAAAAAAAACIABAAAAC0BBAAEAAAA8AEHAAcAAAD8AgAAmTNmAoAgBAAAAC0BBwAEAAAA8AEDAAUAAAABApkzZgIEAAAABAENAAQAAAACAQIABwAAABsEYwBJAVwAQgEEAAAALQEFAAQAAAAtAQYABAAAAC0BAgAEAAAAJwH//wMAAAAeAAQAAAAtAQEABAAAAC0BBwAEAAAALQEEAAUAAAABApkzZgIFAAAACQLM/8wCBwAAABYEeQBQAUMAPgEEAAAALQEFAAQAAAAtAQYABAAAAC0BAgAEAAAAJwH//wMAAAAeAAQAAAAtAQEABAAAAC0BBwAEAAAALQEEAAUAAAABApkzZgIFAAAACQLM/8wCBwAAABYEeQBQAUMAPgEJAAAA+gIAAAEAAAAAAAAAIgAEAAAALQEDAAQAAADwAQQABwAAAPwCAAD//8wCgCAEAAAALQEEAAQAAADwAQcABQAAAAEC///MAgQAAAAEAQ0ABAAAAAIBAgAHAAAAGwR1AEkBbgBCAQQAAAAtAQUABAAAAC0BBgAEAAAALQECAAQAAAAnAf//AwAAAB4ABAAAAC0BAQAEAAAALQEEAAQAAAAtAQMABQAAAAEC///MAgUAAAAJAsz/zAIHAAAAFgR5AFABQwA+AQQAAAAtAQUABAAAAC0BBgAEAAAALQECAAQAAAAnAf//AwAAAB4ABAAAAC0BAQAEAAAALQEEAAQAAAAtAQMABQAAAAEC///MAgUAAAAJAsz/zAIHAAAAFgS9AFkBAAAAAAcAAAD8AgAAAAAAAAAABAAAAC0BBwAEAAAA8AEEAAQAAAAtAQUABAAAAPABAwAEAAAAJwH//wUAAAAMAr0AWQEDAAAAHgAFAAAAAQL//8wCBQAAAAkCzP/MAgQAAAAnAf//BQAAAAsCAAAAAAMAAAAeAAUAAAABAv//zAIFAAAACQLM/8wCBAAAACcB//8DAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=" />
	
	PROCEDURE Init
		THIS.SetupGraph()
	ENDPROC

	PROCEDURE laddlegend_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal)="L"
			THIS.lAddlegend = m.vNewVal
			THIS.AutoGraph.lAddlegend = m.vNewVal
			THIS.RefreshGraph()
		ENDIF
	ENDPROC

	PROCEDURE lseriesbyrow_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal)="L"
			THIS.lseriesbyrow = m.vNewVal
			THIS.AutoGraph.lseriesbyrow = m.vNewVal
			THIS.RefreshGraph()
		ENDIF
	ENDPROC

	PROCEDURE ncharttype_assign
		LPARAMETERS m.vNewVal
		IF VARTYPE(m.vNewVal)="N"
			THIS.ncharttype = m.vNewVal
			THIS.AutoGraph.ncharttype = m.vNewVal
			THIS.RefreshGraph()
		ENDIF
		
	ENDPROC

	PROCEDURE refreshgraph		&& Refreshes graph when record pointer moved.
		IF EMPTY(ALIAS())
			RETURN .F.
		ENDIF
		
		THISFORM.LockScreen = .T.
		
		WITH THIS.Autograph
			.graphpreview = THISFORM					&& the form
			.oGraphRef = THIS.oleGraph.object			&& and the ole control object
			.lAddedData = .F.
			DO CASE
			CASE !EMPTY(THIS.cGraphField)
				.lAddTitle = .T.
				.cTitle = EVAL(THIS.cGraphField)
			CASE !EMPTY(THIS.cGraphTitle)
				.lAddTitle = .T.
				.cTitle = IIF(THIS.cGraphTitle=C_RECDESC_LOC,;
					C_RECDESC_LOC+" "+TRANS(RECNO()),THIS.cGraphTitle)
			OTHERWISE
				.lAddTitle = .F.
			ENDCASE
			IF !.MakeOutput()
				MESSAGEBOX(ERR_NOGRAPH_LOC)
			ENDIF	
			.graphpreview = null
			.oGraphRef = null
		ENDWITH
		
		THIS.OleGraph.Visible = .T.
		
		THISFORM.LockScreen = .F.
		
	ENDPROC

	PROCEDURE setcharttype		&& Sets the chart type.
		LPARAMETER nIndex
		
		IF VARTYPE(m.nIndex)#"N"
			RETURN .F.
		ENDIF
		
		LOCAL lnChartType,nChartValue
		
		nChartValue = m.nIndex
		
		DO CASE
		CASE m.nChartValue = 1	&&Area
			lnChartType = I_AREA_GRAPH
		CASE m.nChartValue = 2	&&Area 3D
			lnChartType = I_AREA3D_GRAPH
		CASE m.nChartValue = 3	&&Bar
			lnChartType = I_BAR_GRAPH
		CASE m.nChartValue = 4	&&Bar 3D
			lnChartType = I_BAR3D_GRAPH
		CASE m.nChartValue = 5	&&Column
			lnChartType = I_COLUMN_GRAPH
		CASE m.nChartValue = 6	&&Column 3D
			lnChartType = I_COLUMN3D_GRAPH
		CASE m.nChartValue = 7	&&Pie
			lnChartType = I_PIE_GRAPH
		CASE m.nChartValue = 8	&&Pie 3D
			lnChartType = I_PIE3D_GRAPH
		CASE m.nChartValue = 9	&&Line
			lnChartType = I_LINE_GRAPH
		CASE m.nChartValue = 10	&&Line 3D
			lnChartType = I_LINE3D_GRAPH
		ENDCASE
		
		THIS.nChartType = lnChartType
		
	ENDPROC

	PROCEDURE setupgraph		&& Initializes graph controls.
		LOCAL i
		
		IF EMPTY(ALIAS())
			WAIT WINDOW C_NOALIAS_LOC TIMEOUT 2
			RETURN .F.
		ENDIF
		
		* Check if no THIS.aDataFields array not populated by user.
		IF EMPTY(THIS.aDataFields[1])
			FOR i = 2 TO FCOUNT()
				IF ATC(TYPE("EVAL(FIELD(m.i))"),"CLGDMT")#0
					LOOP
				ENDIF
				IF !EMPTY(THIS.aDataFields[1])
					DIMENSION THIS.aDataFields[ALEN(THIS.aDataFields)+1]
				ENDIF
				THIS.aDataFields[ALEN(THIS.aDataFields)] = FIELD(m.i)
			ENDFOR
		ENDIF
		
		ACOPY(THIS.aDataFields,THIS.Autograph.aDataFields)
		
		WITH THIS.autograph
			.lGraphRecord = .t.							&& graph just one record
			.nAction = 0								&& preview/display mode
			.lAddlegend = THIS.lAddlegend 				&& data is in rows
			.lSeriesByRow = THIS.lSeriesByRow			&& data is in rows
			.nChartType = THIS.nChartType				&& line chart
			.lStripExcessLegend = .t.					&& if MS Graph adds extra legends, get rid of them
			.lUse8Type = .t.							&& use documented graph types
			.lShowWhenDone = .F.						&& don't display (our form will handle it)
			.lKeepForm = .T.							&& don't reset form (use this one)
		ENDWITH
		
		THIS.RefreshGraph()
		
	ENDPROC

	PROCEDURE cboChartType.Init
		THIS.AddItem(C_AREA_GRAPH)
		THIS.AddItem(C_AREA3D_GRAPH)
		THIS.AddItem(C_BAR_GRAPH)
		THIS.AddItem(C_BAR3D_GRAPH)
		THIS.AddItem(C_COLUMN_GRAPH)
		THIS.AddItem(C_COLUMN3D_GRAPH)
		THIS.AddItem(C_PIE_GRAPH)
		THIS.AddItem(C_PIE3D_GRAPH)
		THIS.AddItem(C_LINE_GRAPH)
		THIS.AddItem(C_LINE3D_GRAPH)
		
		LOCAL nGetValue,lnChartType
		nGetValue = THIS.Parent.nChartType
		IF VARTYPE(nGetValue)#"N"
			nGetValue = I_AREA_GRAPH
		ENDIF
		
		DO CASE
		CASE m.nGetValue= I_AREA_GRAPH	&&Area
			lnChartType = C_AREA_GRAPH
		CASE m.nGetValue= I_AREA3D_GRAPH	&&Area 3D
			lnChartType = C_AREA3D_GRAPH
		CASE m.nGetValue= I_BAR_GRAPH	&&Bar
			lnChartType = C_BAR_GRAPH
		CASE m.nGetValue = I_BAR3D_GRAPH	&&Bar 3D
			lnChartType = C_BAR3D_GRAPH
		CASE m.nGetValue = I_COLUMN_GRAPH	&&Column
			lnChartType = C_COLUMN_GRAPH
		CASE m.nGetValue = I_COLUMN3D_GRAPH	&&Column 3D
			lnChartType = C_COLUMN3D_GRAPH
		CASE m.nGetValue = I_PIE_GRAPH	&&Pie
			lnChartType = C_PIE_GRAPH
		CASE m.nGetValue = I_PIE3D_GRAPH	&&Pie 3D
			lnChartType = C_PIE3D_GRAPH
		CASE m.nGetValue = I_LINE_GRAPH	&&Line
			lnChartType = C_LINE_GRAPH
		CASE m.nGetValue = I_LINE3D_GRAPH	&&Line 3D
			lnChartType = C_LINE3D_GRAPH
		ENDCASE
		
		THIS.Value = lnChartType
		
	ENDPROC

	PROCEDURE cboChartType.InteractiveChange
		THIS.Parent.SetChartType(THIS.ListIndex)
		
	ENDPROC

	PROCEDURE chkPlotBy.Click
		THIS.Parent.lSeriesByRow = THIS.Value
		
	ENDPROC

	PROCEDURE chkPlotBy.Init
		THIS.Value = THIS.Parent.lSeriesByRow
	ENDPROC

	PROCEDURE chkShowLegend.Click
		THIS.Parent.lAddLegend = THIS.Value
	ENDPROC

	PROCEDURE chkShowLegend.Init
		THIS.Value = THIS.Parent.lAddLegend
	ENDPROC

	PROCEDURE _nav4buttons.tablenav
		LPARAMETERS tcAction
		DODEFAULT(tcAction)
		THIS.Parent.RefreshGraph()
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _stringlib AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: trimcrlf		&& Trims carriage returns and line feeds from string.
	*</DefinedPropArrayMethod>

	Height = 23
	Name = "_stringlib"
	Width = 24
	
	PROCEDURE trimcrlf		&& Trims carriage returns and line feeds from string.
		LPARAMETERS tcString,tlTrimLeft,tlTrimRight
		LOCAL lcString
		
		lcString=tcString
		IF tlTrimLeft
			DO WHILE LEFT(lcString,1)==CHR(13) OR LEFT(lcString,1)==CHR(10)
				lcString=LTRIM(SUBSTR(lcString,2))
			ENDDO
		ENDIF
		IF tlTrimRight
			DO WHILE RIGHT(lcString,1)==CHR(13) OR RIGHT(lcString,1)==CHR(10)
				lcString=TRIM(LEFT(lcString,LEN(lcString)-1))
			ENDDO
		ENDIF
		RETURN lcString
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _typelib AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "_utility.h"
	*<DefinedPropArrayMethod>
		*m: alert		&& Displays alert messagebox.
		*m: checkclass		&& Sets class as current one from a type library.
		*m: checktliapp		&& Checks and loads type library reader application.
		*m: checktypelib		&& Checks and loads type library from COM server file.
		*m: checkvariant		&& Checks if a variant data type is used in method for parameter or return type.
		*m: exporttypelib		&& Method to export typelib to file.
		*m: getclasses		&& Returns array of classes in specified type library.
		*m: getinvokekind
		*m: getmethods		&& Returns array of methods in specified class of type library.
		*m: getparminfo		&& Returns array of parameter info for a method in a class in specified type library.
		*m: vartypetostring		&& Returns data type (string) from numeric reference.
		*p: cclass		&& Name of class.
		*p: ccomfile		&& Name of COM file being.
		*p: cerrormessage		&& Error message.
		*p: ctypelib		&& Name of type library.
		*p: lhaderror		&& Whether an error has happened.
		*p: lskipalerts		&& Whether to skip alerts.
		*p: nclassref		&& Numeric reference to selected class in classes array.
		*p: oclass		&& Object reference to class in type library.
		*p: otliapp		&& Object reference to type library reader application.
		*p: otypelib		&& Object reference to type library.
		*a: aints[1,0]		&& Array of interfaces.
		*a: omethods[1,0]		&& Object references array to methods of a class in type library.
	*</DefinedPropArrayMethod>

	cclass = 		&& Name of class.
	ccomfile = 		&& Name of COM file being.
	cerrormessage = 		&& Error message.
	ctypelib = 		&& Name of type library.
	Height = 27
	Name = "_typelib"
	Width = 101
	
	PROCEDURE alert		&& Displays alert messagebox.
		LPARAMETERS tcMessage
		IF _VFP.StartMode#0 OR THIS.lSkipAlerts
			THIS.cErrorMessage = tcMessage
		ELSE
			MESSAGEBOX(tcMessage,16)
		ENDIF
		
	ENDPROC

	PROCEDURE checkclass		&& Sets class as current one from a type library.
		LPARAMETERS eClass, nClassType, eTypelib
		
		* nClassType details:
		* 0 - eClass passed in is class name (default)
		* 1 - eClass passed in is progid name
		* 2 - eClass passed in is interface name
		* ex. for a ProgID of "VFPTEST.STOCK", pass in
		*   0 - "STOCK"
		*   1 - "VFPTEST.STOCK"
		*   2 - "ISTOCK"
		
		LOCAL lnClassType,lnClasses,i,lcStr,loClass
		
		IF !THIS.CheckTypeLib(eTypelib)
			RETURN .F.
		ENDIF
		
		IF VARTYPE(eClass)="C" AND !EMPTY(eClass)
			IF VARTYPE(nClassType)#"N" OR !BETWEEN(nClassType,0,2)
				lnClassType=0
			ENDIF
			lnClasses = THIS.otypelib.CoClasses.Count
			FOR i = 1 TO lnClasses
				DO CASE
				CASE lnClassType=1
					lcStr = UPPER(THIS.otypelib.Name+"."+THIS.otypelib.CoClasses(m.i).Name)
				CASE lnClassType=2
					lcStr = UPPER(THIS.otypelib.CoClasses(m.i).DefaultInterface.Name)
				OTHERWISE
					lcStr = UPPER(THIS.otypelib.CoClasses(m.i).Name)
				ENDCASE
				IF UPPER(eClass)==lcStr
					THIS.nClassRef = m.i
					THIS.oClass = THIS.otypelib.CoClasses(m.i).DefaultInterface
					RETURN .T.
				ENDIF
			ENDFOR
			RETURN .F.
		ENDIF
		
		RETURN VARTYPE(THIS.oClass)="O"
		
	ENDPROC

	PROCEDURE checktliapp		&& Checks and loads type library reader application.
		IF VARTYPE(THIS.oTLIApp)#"O"
			THIS.oTLIApp = CREATEOBJECT(TLIAPP_PROGID)
			IF VARTYPE(THIS.oTLIApp)#"O"
				RETURN .F.
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE checktypelib		&& Checks and loads type library from COM server file.
		LPARAMETERS eTypelib
		
		LOCAL lnClassCount, loTypelib, lcTypelib
		
		IF !THIS.CheckTLIApp()
			RETURN .F.
		ENDIF
		
		* Check for valid typelib file passed
		IF VARTYPE(eTypelib)="C" AND !EMPTY(eTypelib)
			IF !FILE(eTypelib)
				RETURN .F.
			ENDIF
			THIS.cTypelib = eTypelib
		ENDIF
		
		* Check if user passed in an IDispath object instead of typelib name
		IF VARTYPE(eTypelib)="O"
			THIS.lHadError = .F.
			loTypelib = THIS.oTLIApp.InterfaceInfoFromObject(eTypelib)
			IF THIS.lHadError OR VARTYPE(loTypelib)#"O"
				THIS.lHadError = .F.
				RETURN .F.
			ENDIF
			THIS.oTypelib = loTypelib.Parent
			THIS.cTypelib = loTypelib.Parent.ContainingFile
			RETURN .T.
		ENDIF
		
		* Check for valid cTypelib property (possibly set)
		IF VARTYPE(THIS.cTypelib )="C" AND !EMPTY(THIS.cTypelib)
			IF !FILE(THIS.cTypelib)
				RETURN .F.
			ENDIF
		ENDIF
		
		* Check for valid oTypelib property
		IF VARTYPE(THIS.oTypelib)="O" AND UPPER(THIS.oTypelib.ContainingFile)==UPPER(THIS.cTypelib)
			RETURN .T.
		ENDIF
		
		* Need to check if valid
		THIS.lHadError = .F.
		THIS.lignoreerrors = .T.
		loTypelib = THIS.oTLIApp.TypeLibInfoFromFile(THIS.cTypelib)
		THIS.lignoreerrors = .F.
		IF THIS.lHadError OR VARTYPE(loTypelib)#"O"
			THIS.lHadError = .F.
			THIS.ALERT(BADTYPELIB_LOC)
			RETURN .F.
		ENDIF
		lnClassCount = loTypelib.CoClasses.Count
		IF lnClassCount=0
			RETURN .F.
		ENDIF
		
		* Successful check, so let's set oTypelib property
		THIS.oTypelib = loTypelib
		
	ENDPROC

	PROCEDURE checkvariant		&& Checks if a variant data type is used in method for parameter or return type.
		LPARAMETERS tcInterface
		* Checks for Variant return type or parameter type which are not supported in SOAP.
		* Used for Web Services only since it doesn't check properties
		LOCAL lnMCount, lnPCount, laMeths, laParms, i, j
		DIMENSION laMeths[1]
		lnMCount = THIS.GetMethods(@laMeths,tcInterface, .F., .F., .T.)
		FOR i = 1 TO lnMCount
			* Check for valid return type -- fail for Currency or Variant
			IF INLIST(laMeths[m.i,2],6,12)
				RETURN .F.
			ENDIF
			DIMENSION laParms[1]
			lnPCount = THIS.GetParmInfo(@laParms,THIS.oMethods(m.i))
			FOR j = 1 TO lnPCount
				* Check for valid parameter type
				IF INLIST(laParms[m.j,2],6,12)
					RETURN .F.
				ENDIF
			ENDFOR
		ENDFOR
		
	ENDPROC

	PROCEDURE Destroy
		THIS.omethods = null
		THIS.oclass = null
		THIS.otliapp = null
		THIS.otypelib = null
		THIS.aInts = null
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		THIS.lhaderror = .T.
		IF THIS.lIgnoreErrors OR INLIST(nError,1113, 1426, 2012) OR _VFP.StartMode>0
			RETURN
		ELSE
			RETURN DODEFAULT(nError, cMethod, nLine)
		ENDIF
	ENDPROC

	PROCEDURE exporttypelib		&& Method to export typelib to file.
		* You can use this method to export the contents of a type library to a text file. 
		LPARAMETER cExportFile, lNoViewFile
		LOCAL cOldSafe,i,j,k,lcTmpStr
		LOCAL lnClasses,laClasses,lnMethods,laMethods,laParms,lnParms
		lcTmpStr=""
		IF TYPE("THIS.ctypelib")#"C" OR EMPTY(THIS.ctypelib)
			THIS.ctypelib = GETFILE(GETFILE1_LOC,GETFILE2_LOC)
		ENDIF
		
		IF EMPTY(THIS.ctypelib) OR !FILE(THIS.ctypelib)
			RETURN ""
		ENDIF
		
		IF TYPE("m.lNoViewFile")#"L"
			m.lNoViewFile = .F.
		ENDIF
		
		IF TYPE("m.cExportFile")#"C" OR EMPTY("m.cExportFile")
			m.cExportFile = JustStem(THIS.ctypelib) + ".TXT"
		ENDIF
		cOldSafe = SET("SAFETY")
		SET SAFETY OFF
		
		IF WEXIST(m.cExportFile)
			RELEASE WINDOW (m.cExportFile)
		ENDIF
		
		SET TEXTMERGE ON NOSHOW
		SET TEXTMERGE TO MEMVAR lcTmpStr
		
		* Gather and output Typelib information
		\ <<TYPELIBSPACING + TLIB1_LOC>>  <<THIS.ctypelib>>
		DIMENSION laClasses[1]
		lnClasses=THIS.Getclasses(@laClasses)
		FOR i = 1 TO lnClasses
			\ <<TYPEINFOSPACING+TCLASS_LOC+laClasses[m.i, 1]>>  <<laClasses[m.i, 2]>>
			\
			DIMENSION laMethods[1]
			lnMethods=THIS.GetMethods(@laMethods,laClasses[m.i, 1])
			FOR j = 1 TO lnMethods
				\ <<FUNCDESCSPACING + laMethods[m.j, 1] + "(">>
				DIMENSION laParms[1]
				lnParms=THIS.Getparminfo(@laParms,THIS.oMethods[m.j])
				FOR k = 1 TO lnParms
					\\ <<laParms[m.k, 1] + " AS " + THIS.Vartypetostring(laParms[m.k, 2]) + IIF(laParms[m.k, 3]," @","")>>
					IF k < lnParms
						\\", "
					ENDIF
				ENDFOR
				\\<<") AS " +THIS.vartypetostring(laMethods[m.j, 2])>>
				\ <<FUNCDESCSPACING + "Type: "+THIS.Getinvokekind(THIS.oMethods[m.j].InvokeKind)>>
				IF !EMPTY(ALLTRIM(laMethods[m.j, 3]))
					\ <<FUNCDESCSPACING + laMethods[m.j, 3]>>
				ENDIF
				\
			ENDFOR
			\
		ENDFOR
		
		SET TEXTMERGE TO
		SET TEXTMERGE OFF
		IF !EMPTY(lcTmpStr)
			STRTOFILE(lcTmpStr, m.cExportFile)
		ENDIF
		
		SET SAFETY &cOldSafe
		IF !m.lNoViewFile AND !EMPTY(lcTmpStr)
			MODIFY FILE (m.cExportFile) NOWAIT
		ENDIF
		RETURN m.cExportFile
		
	ENDPROC

	PROCEDURE getclasses		&& Returns array of classes in specified type library.
		LPARAMETERS aClasses, eTypelib, lReturnProgID
		
		LOCAL lnClasses, i, lUseProgID
		
		IF !THIS.CheckTypeLib(eTypelib)
			RETURN 0
		ENDIF
		
		IF VARTYPE(lReturnProgID)="L"
			lUseProgID = lReturnProgID
		ENDIF
		
		lnClasses = THIS.otypelib.CoClasses.Count
		IF lnClasses > 0
			DIMENSION aClasses[lnClasses,2]
			FOR i = 1 TO lnClasses
				IF lUseProgID
					aClasses[m.i,1] = THIS.otypelib.Name + "." + THIS.otypelib.CoClasses(m.i).Name
				ELSE
					aClasses[m.i,1] = THIS.otypelib.CoClasses(m.i).Name		
				ENDIF
				aClasses[m.i,2] = THIS.otypelib.CoClasses(m.i).GUID		
			ENDFOR
		ENDIF
		
		RETURN lnClasses
		
	ENDPROC

	PROCEDURE getinvokekind
		LPARAMETERS nKind
		DO CASE
		CASE nKind= 0
			RETURN "Unknown"
		CASE nKind= 1
			RETURN "Function"
		CASE nKind= 2
			RETURN "PropertyGet"
		CASE nKind= 4
			RETURN "PropertyPut"
		CASE nKind= 8
			RETURN "PropertyPutRef"
		CASE nKind= 16
			RETURN "EventFunction"
		CASE nKind= 32
			RETURN "CONST"
		OTHERWISE
			RETURN "Unknown"
		ENDCASE
	ENDPROC

	PROCEDURE getmethods		&& Returns array of methods in specified class of type library.
		LPARAMETERS aMethods, eClass, nClassType, etypelib, lMethodsOnly, lIncludeHidden
		* nClassType - see CheckClass method
		* populates aMethods array:
		*  element 1 - name
		*  element 2 - return type (numeric)
		*  element 3 - help string
		* also populates THIS.aMethods array with obj refs
		
		* InvokeKind:
		* 0 - Unknown
		* 1 - Function
		* 2 - PropertyGet
		* 4 - PropertyPut
		* 8 - PropertyPutRef
		* 16 - EventFunction
		* 32 - CONST
		
		LOCAL i, lnMemCount, lnMaxArr
		IF !THIS.CheckClass(eClass, nClassType, eTypelib)
			RETURN 0
		ENDIF
		lnMaxArr=0
		lnMemCount = THIS.oClass.Members.Count
		IF lnMemCount > 0
			DIMENSION aMethods[1,3]
			DIMENSION THIS.oMethods[1]
			aMethods=""
			FOR i = 1 TO lnMemCount
				* Skip hidden/restricted members (e.g., QueryInterface)
				DO CASE
				CASE m.lMethodsOnly AND THIS.oClass.Members(m.i).InvokeKind #1			&& properties
					LOOP
				CASE m.lIncludeHidden
				CASE BITTEST(THIS.oClass.Members(m.i).AttributeMask, 0)  					&& hidden and restricted
					LOOP
				ENDCASE
				lnMaxArr = ALEN(aMethods,1)
				IF !EMPTY(aMethods)
					lnMaxArr = lnMaxArr+1
					DIMENSION aMethods[lnMaxArr,3]
					DIMENSION THIS.oMethods[lnMaxArr]
				ENDIF
				aMethods[lnMaxArr,1] = THIS.oClass.Members(m.i).Name
				aMethods[lnMaxArr,2] = THIS.oClass.Members(m.i).ReturnType.VarType
				aMethods[lnMaxArr,3] = THIS.oClass.Members(m.i).HelpString
				THIS.oMethods[lnMaxArr] = THIS.oClass.Members(m.i)
			ENDFOR
			lnMemCount = lnMaxArr
		ENDIF
		RETURN lnMemCount
		
	ENDPROC

	PROCEDURE getparminfo		&& Returns array of parameter info for a method in a class in specified type library.
		LPARAMETERS aParmInfo, oMethod
		* populates aParmInfoarray:
		*  element 1 - name
		*  element 2 - type (numeric)
		*  element 3 - byref
		
		LOCAL lnParmCount,i,lnMaxArr
		IF VARTYPE(oMethod)#"O"
			RETURN 0
		ENDIF
		
		lnParmCount = oMethod.Parameters.Count
		IF lnParmCount>0
			DIMENSION aParmInfo[1,3]
			aParmInfo=""
			FOR i = 1 TO lnParmCount
				lnMaxArr = ALEN(aParmInfo,1)
				IF !EMPTY(aParmInfo)
					lnMaxArr = lnMaxArr+1
					DIMENSION aParmInfo[lnMaxArr,3]
				ENDIF
				aParmInfo[lnMaxArr,1] = oMethod.Parameters(m.i).Name
				aParmInfo[lnMaxArr,2] = oMethod.Parameters(m.i).VarTypeInfo.VarType
				aParmInfo[lnMaxArr,3] = (BITAND(oMethod.Parameters(m.i).flags,3)=3)
			ENDFOR
		ENDIF
		RETURN lnParmCount
		
	ENDPROC

	PROCEDURE vartypetostring		&& Returns data type (string) from numeric reference.
		LPARAMETERS nType
		
		DO CASE
		CASE ntype = 0		&& VT_EMPTY
			RETURN "variant"
		CASE ntype = 1		&& VT_NULL
			RETURN "NULL"
		CASE ntype = 2		&& VT_I2
			RETURN "integer"
		CASE nType = 3		&& VT_I4
			RETURN "long"
		CASE nType = 4		&& VT_R4
			RETURN "single"
		CASE nType = 5		&& VT_R8
			RETURN "double"
		CASE nType = 6		&& VT_CT
			RETURN "currency"
		CASE ntype = 7
			RETURN "date"
		CASE ntype = 8
			RETURN "string"
		CASE ntype = 9		&& VT_DISPATCH
			RETURN "VARIANT"
		CASE nType = 11
			RETURN "boolean"
		CASE nType = 12		&& VT_VARIANT
			RETURN "variant"
		CASE nType = 16 	&& VT_I1
			RETURN "number"
		CASE nType = 17 	&& VT_UI1
			RETURN "number"
		CASE nType = 18 	&& VT_UI2
			RETURN "number"
		CASE nType = 19 	&& VT_UI4
			RETURN "number"
		CASE nType = 22		&& VT_INT
			RETURN "integer"
		CASE nType = 23		&& VT_UINT
			RETURN "integer"
		CASE nType = 24		&& VT_VOID
			RETURN "VOID"
		CASE nType = 25		&& VT_HRESULT
			RETURN "VOID"
		OTHERWISE
			RETURN "variant"
		ENDCASE
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _xtab AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	*<DefinedPropArrayMethod>
		*m: runxtab		&& Generates cross tab.
		*p: coutfile		&& Name of the output file.
		*p: lbrowseafter		&& Whether to browse cross tab output after being generated.
		*p: lclosetable		&& Whether to close source datasource after cross tab is generated.
		*p: lcursoronly		&& Whether input datasource is cursor.
		*p: ldisplaynulls		&& Whether to display nulls in cross tab output.
		*p: lshowthem		&& Whether to show thermometer during cross tab generation.
		*p: ltotalrows		&& Whether to total rows in cross tab output.
		*p: ncolfield		&& Field position in datasource of cross tab columns.
		*p: ndatafield		&& Field position in datasource of cross tab data.
		*p: nrowfield		&& Field position in datasource of cross tab rows.
		*p: ntotaloption		&& Totaling options (0-sum, 1-count, 2-% of total).
	*</DefinedPropArrayMethod>

	coutfile = xtabquery		&& Name of the output file.
	lbrowseafter = .T.		&& Whether to browse cross tab output after being generated.
	lclosetable = .T.		&& Whether to close source datasource after cross tab is generated.
	lcursoronly = .T.		&& Whether input datasource is cursor.
	lshowthem = .T.		&& Whether to show thermometer during cross tab generation.
	Name = "_xtab"
	ncolfield = 2		&& Field position in datasource of cross tab columns.
	ndatafield = 3		&& Field position in datasource of cross tab data.
	nrowfield = 1		&& Field position in datasource of cross tab rows.
	ntotaloption = 0		&& Totaling options (0-sum, 1-count, 2-% of total).
	
	PROCEDURE runxtab		&& Generates cross tab.
		LOCAL oNewXtab,lcxtabfile
		
		lcxtabfile = IIF(EMPTY(_GENXTAB),"vfpxtab.prg",_GENXTAB)
		
		oNewXtab=NEWOBJECT('genxtab',lcxtabfile,"",;
		THIS.cOutFile,;
		THIS.lCursorOnly,;
		THIS.lCloseTable,;
		THIS.lShowThem,;
		THIS.nRowField,;
		THIS.nColField,;
		THIS.nDataField,;
		THIS.lTotalRows,;
		THIS.nTotalOption,;
		THIS.lDisplayNulls)
		
		oNewXtab.MakeXtab()
		
		IF THIS.lBrowseAfter
			BROWSE NOWAIT NORMAL
		ENDIF
		
	ENDPROC

ENDDEFINE
