*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="_dataquery.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
*
DEFINE CLASS _cbodistinctvalues AS _combobox OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "_data.h"
	FontName = "MS Sans Serif"
	FontSize = 8
	Height = 23
	Name = "_cbodistinctvalues"
	Width = 175
	
	PROCEDURE Destroy
		LOCAL cCursor
		
		cCursor = "c" + THIS.name
		IF USED(m.cCursor) THEN
			USE IN &cCursor
		ENDIF
		
	ENDPROC

	PROCEDURE Init
		LOCAL cSQL, cAlias, cColumn
		
		IF !EMPTY(THIS.controlSource) THEN
			IF NOT "." $ THIS.controlSource THEN
				=MESSAGEBOX(NO_TABLE_LOC)
			ELSE
				cAlias = LEFTC(THIS.controlSource,(ATC(".",THIS.controlSource)-1))
				cColumn = RIGHTC(THIS.controlSource,(LENC(THIS.controlSource)-ATC(".",THIS.controlSource)))
				IF INLIST(TYPE(m.cAlias+"."+m.cColumn),"D","T","M","G","L")
					RETURN
				ENDIF
				THIS.rowSourceType = 3
				cSQL = "SELECT DISTINCT " + m.cColumn + " FROM " + m.cAlias + ;
				  " INTO CURSOR c" + THIS.name
				THIS.rowSource = m.cSQL
			ENDIF
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _cbolookup AS _combobox OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="combobox" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "_data.h"
	*<DefinedPropArrayMethod>
		*p: display_column		&& Specifies the column from lookup_table to display in the drop down list.
		*p: lookup_table		&& Specifies the table to lookup the values to display in the drop down.
		*p: order_column		&& Specifies the column to order the records displayed in the drop down list (optional).
		*p: return_column		&& Specifies the column value to return the value property of the combo box.
	*</DefinedPropArrayMethod>

	display_column = 		&& Specifies the column from lookup_table to display in the drop down list.
	FontName = "MS Sans Serif"
	FontSize = 8
	Height = 23
	lookup_table = 		&& Specifies the table to lookup the values to display in the drop down.
	Name = "_cbolookup"
	order_column = 		&& Specifies the column to order the records displayed in the drop down list (optional).
	return_column = 		&& Specifies the column value to return the value property of the combo box.
	Style = 2
	Width = 175
	
	PROCEDURE Destroy
		LOCAL cAlias
		
		cAlias = THIS.name
		IF USED(m.cAlias) THEN
			USE IN &cAlias
		ENDIF
		
	ENDPROC

	PROCEDURE Error
		LPARAMETERS nError, cMethod, nLine
		
		#DEFINE INVALID_COLUMN_LOC "An invalid display column or return column has been specified in the 'display_column' or 'return_column' properties (combo box " + THIS.name + ")."
		#DEFINE INVALID_TABLE_LOC "An invalid table has been specified in the 'display_column' or 'lookup_table' property (combo box " + THIS.name + ")."
		#DEFINE INVALID_SORT_LOC "An invalid column has been specified in the 'order_column' property (combo box " + THIS.name + ")."
		
		DO CASE
			CASE nError = 1806
				=MESSAGEBOX(INVALID_COLUMN_LOC,48)
			CASE nError = 1808
				=MESSAGEBOX(INVALID_SORT_LOC,48)
			CASE nError = 1802
				=MESSAGEBOX(INVALID_TABLE_LOC,48)
			OTHERWISE
				=MESSAGEBOX(MESSAGE(),48)
		ENDCASE
		
	ENDPROC

	PROCEDURE Init
		LOCAL lOK, nSQL
		
		lOK = .T.
		DO CASE
			CASE EMPTY(THIS.lookup_table)
				=MESSAGEBOX(NO_LOOKUP_TABLE_LOC,48)
				lOK = .F.
			CASE EMPTY(THIS.display_column)
				=MESSAGEBOX(NO_DISPLAY_COLUMN_LOC,48)
				lOK = .F.
			CASE EMPTY(THIS.return_column)
				=MESSAGEBOX(NO_RETURN_COLUMN_LOC,48)
				lOK = .F.
		ENDCASE
		
		IF lOK THEN
			IF !EMPTY(THIS.order_column)
				nSQL = "SELECT " + THIS.display_column + "," + THIS.return_column + " FROM " + THIS.lookup_table + " ORDER BY " + THIS.order_column + " INTO CURSOR " + THIS.name
			ELSE
				nSQL = "SELECT " + THIS.display_column + "," + THIS.return_column + " FROM " + THIS.lookup_table + " INTO CURSOR " + THIS.name
			ENDIF
			THIS.RowSourceType = 3
			THIS.RowSource = nSQL
			THIS.BoundColumn = 2
		ENDIF
		THIS.Refresh
	ENDPROC

ENDDEFINE

DEFINE CLASS _conflicts AS _form OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="grdConflicts" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdUpdate" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdRevert" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClose" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="Label3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdSkip" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblConflicts" UniqueID="" Timestamp="" />

	#INCLUDE "_data.h"
	*<DefinedPropArrayMethod>
		*m: alert
		*m: checksource
		*m: nextconflict
		*m: startcheck		&& Checks for conflicts in buffered data of alias.
		*p: conflictalias
		*p: cursoralias		&& Name of alias to check for conflicts.
		*p: lautocheck		&& Automatically check on startup.
		*p: lrowconflict
		*a: aconflicts[1,0]
	*</DefinedPropArrayMethod>

	AlwaysOnTop = .T.
	AutoCenter = .T.
	Caption = "Resolve Conflicts"
	conflictalias = 
	cursoralias = 		&& Name of alias to check for conflicts.
	DoCreate = .T.
	Height = 183
	lautocheck = .T.		&& Automatically check on startup.
	MaxButton = .F.
	MinButton = .F.
	Name = "_conflicts"
	Width = 490
	WindowType = 1

	ADD OBJECT 'cmdClose' AS _commandbutton WITH ;
		Caption = "\<Close", ;
		Height = 23, ;
		Left = 406, ;
		Name = "cmdClose", ;
		Top = 149, ;
		Width = 72
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdRevert' AS _commandbutton WITH ;
		Caption = "\<Revert", ;
		Height = 23, ;
		Left = 262, ;
		Name = "cmdRevert", ;
		Top = 149, ;
		Width = 72
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdSkip' AS _commandbutton WITH ;
		Caption = "\<Ignore", ;
		Height = 23, ;
		Left = 334, ;
		Name = "cmdSkip", ;
		Top = 149, ;
		Width = 72
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdUpdate' AS _commandbutton WITH ;
		Caption = "\<Update", ;
		Height = 23, ;
		Left = 190, ;
		Name = "cmdUpdate", ;
		Top = 149, ;
		Width = 72
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'grdConflicts' AS _grid WITH ;
		ColumnCount = -1, ;
		Height = 90, ;
		Highlight = .F., ;
		HighlightRow = .F., ;
		Left = 108, ;
		Name = "grdConflicts", ;
		ReadOnly = .T., ;
		RecordSource = "", ;
		ScrollBars = 1, ;
		Top = 48, ;
		Visible = .F., ;
		Width = 370
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="grid" />

	ADD OBJECT 'Label1' AS label WITH ;
		Caption = "Old value", ;
		Height = 15, ;
		Left = 8, ;
		Name = "Label1", ;
		Top = 68, ;
		Width = 96
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label2' AS label WITH ;
		Caption = "Current value", ;
		Height = 15, ;
		Left = 8, ;
		Name = "Label2", ;
		Top = 88, ;
		Width = 96
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'Label3' AS label WITH ;
		Caption = "New value", ;
		Height = 15, ;
		Left = 8, ;
		Name = "Label3", ;
		Top = 108, ;
		Width = 84
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblConflicts' AS label WITH ;
		Caption = "Conflicts on row:", ;
		Height = 17, ;
		Left = 8, ;
		Name = "lblConflicts", ;
		Top = 17, ;
		Width = 158
		*< END OBJECT: BaseClass="label" />
	
	PROCEDURE alert
		LPARAMETERS cMessage
		WAIT WINDOW m.cMessage TIMEOUT 2
		
	ENDPROC

	PROCEDURE checksource
	ENDPROC

	PROCEDURE Init
		IF !EMPTY(ALIAS()) AND EMPTY(THIS.CursorAlias)
			THIS.CursorAlias = ALIAS()
		ENDIF
		IF THIS.lAutoCheck
			IF !THIS.StartCheck()
				RETURN .F.
			ENDIF
		ENDIF
	ENDPROC

	PROCEDURE nextconflict
		LPARAMETERS lnStartRow
		
		LOCAL lnRow, lcUserField, lnBuffering, nCursorType, lnFields, i 
		
		IF EMPTY(THIS.CursorAlias)
			THIS.Alert(CS_NOALIAS_LOC)
			THISFORM.release()
			RETURN .F.
		ENDIF
		
		SELECT (THIS.CursorAlias)
		
		* default start row is current row
		IF PCOUNT() = 0
			lnStartRow = RECNO()
		ENDIF
		
		* close form after single row conflicts
		lnBuffering = CURSORGETPROP('Buffering')
		IF lnBuffering = 1
			THIS.Alert(CS_NOBUFFER_LOC)
			THISFORM.release()
			RETURN .F.
		ENDIF
		
		IF lnBuffering<4 AND lnStartRow#0
			THISFORM.release()
			RETURN .F.
		ENDIF
		
		nCursorType = CURSORGETPROP("SourceType",THIS.CursorAlias)
		
		IF lnBuffering>3
			* for table buffering move to next row
			lnRow = GETNEXTMODIFIED(lnStartRow,THIS.CursorAlias)
			IF lnRow # 0
				GO lnRow IN (THIS.CursorAlias)
			ENDIF
		ELSE
			* handle row buffering
			lnFields = GETFLDSTATE(-1)
			IF REPLICATE("1",LEN(lnFields))#TRANS(lnFields)
				lnRow = RECNO()
			ELSE
				lnRow = 0	
			ENDIF
		ENDIF
		
		THIS.lblConflicts.caption = CS_ROWCONFLICT_LOC + LTRIM(STR(lnRow,10 , 0))
		IF lnRow = 0
			THIS.Alert(IIF(m.lnStartRow=0,CS_NOCONFLICTS1_LOC,CS_NOCONFLICTS_LOC))
			THISFORM.Release()
			RETURN .F.
		ENDIF
		
		* load original values
		SELECT (THIS.ConflictAlias)
		GO TOP
		FOR m.i = 1 TO ALEN(THIS.aConflicts, 1)
			REPLACE (THIS.aConflicts[m.i,1]) WITH OLDVAL(THIS.aConflicts[m.i,1], THIS.CursorAlias)
		ENDFOR
		
		* load current values
		* add error code here
		
		IF m.nCursorType # 3	&& refresh if not a table
			REFRESH(1, 0, THIS.CursorAlias)
		ENDIF
		
		SKIP
		FOR m.i = 1 TO ALEN(THIS.aConflicts, 1)
			REPLACE (THIS.aConflicts[m.i,1]) WITH CURVAL(THIS.aConflicts[m.i,1], THIS.CursorAlias)
		ENDFOR
		
		* load user values
		SKIP
		FOR m.i = 1 TO ALEN(THIS.aConflicts, 1)
			lcUserField = THIS.CursorAlias + '.' + THIS.aConflicts[m.i,1]
			REPLACE (THIS.aConflicts[m.i,1]) WITH EVALUATE(lcUserField)
		ENDFOR
		
		GO TOP
		THIS.grdConflicts.Refresh
		
		SELECT (THIS.CursorAlias)
		
	ENDPROC

	PROCEDURE QueryUnload
		thisform.RELEASE()
	ENDPROC

	PROCEDURE Release
		IF !EMPTY(THISFORM.ConflictAlias) AND USED(THISFORM.ConflictAlias)
			SELECT (THISFORM.ConflictAlias)
			USE
		ENDIF
		
		IF !EMPTY(THISFORM.CursorAlias) AND USED(THISFORM.CursorAlias)
			SELECT (THISFORM.CursorAlias)
		ENDIF
		
	ENDPROC

	PROCEDURE startcheck		&& Checks for conflicts in buffered data of alias.
		LOCAL aTmpConflicts
		
		IF !EMPTY(ALIAS()) AND EMPTY(THIS.CursorAlias)
			THIS.CursorAlias = ALIAS()
		ENDIF
		
		IF EMPTY(THIS.CursorAlias)
			THIS.Alert(CS_NOALIAS_LOC)
			RETURN .F.
		ENDIF
		
		DIMENSION aTmpConflicts[1]
		DIMENSION THIS.aConflicts[1]
		AFIELDS(aTmpConflicts)
		ACOPY(aTmpConflicts,THIS.aConflicts)
		
		SELECT 0
		CREATE CURSOR _conflicts FROM ARRAY aTmpConflicts
		THIS.ConflictAlias = ALIAS()
		
		* append conflict records
		APPEND BLANK
		APPEND BLANK
		APPEND BLANK
		
		THIS.grdConflicts.RecordSource = THIS.ConflictAlias
		THIS.grdConflicts.Visible = .T.
		
		* move on first conflict
		IF THIS.NextConflict(0)
			THISFORM.Visible = .T.
		ELSE
			RETURN .F.
		ENDIF
		
	ENDPROC

	PROCEDURE cmdClose.Click
		THISFORM.release()
		
	ENDPROC

	PROCEDURE cmdRevert.Click
		IF EMPTY(THISFORM.CursorAlias)
			WAIT WINDOW CS_NOALIAS_LOC TIMEOUT 2
			RETURN .F.
		ENDIF
		
		LOCAL lnRows 
		
		lnRows = TABLEREVERT(.F.)
		THISFORM.CheckSource()
		
		* no conflicts, no row or one row reverted
		THISFORM.Alert( IIF(lnRows = 0,WAIT_REVERTFAIL_LOC,WAIT_REVERT1_LOC))
		THISFORM.NextConflict()
		
	ENDPROC

	PROCEDURE cmdSkip.Click
		THISFORM.NextConflict
		
	ENDPROC

	PROCEDURE cmdUpdate.Click
		IF EMPTY(THISFORM.CursorAlias)
			WAIT WINDOW CS_NOALIAS_LOC TIMEOUT 2
			RETURN .F.
		ENDIF
		
		LOCAL llUpdate
		
		* force-update current row
		llUpdate = TABLEUPDATE(.F., .T.)
		
		THISFORM.CheckSource()
		
		* Display whether update was successful or failed (e.g., primary key changed)
		IF m.llUpdate
			THISFORM.Alert(WAIT_UPDATEOK_LOC)
		ELSE
			THISFORM.Alert(WAIT_UPDATEFAIL1_LOC)
		ENDIF
		
		THISFORM.NextConflict
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _execsp AS _custom OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "_data.h"
	*<DefinedPropArrayMethod>
		*m: dosql		&& Runs SPT statement.
		*m: getsql		&& Gets results from SPT statement.
		*m: processerror
		*m: setparams
		*m: setsql
		*p: ccursorname
		*p: cspname
		*p: csql
		*p: hconnecthandle
		*p: lusesqlsyntax		&& Use SQL Server Exec syntax.
		*a: aparams[1,0]
	*</DefinedPropArrayMethod>

	PROTECTED aparams,ccursorname,cspname,csql,hconnecthandle
	Height = 19
	Name = "_execsp"
	Width = 97
	
	PROCEDURE dosql		&& Runs SPT statement.
		LOCAL nError
		nError = SQLEXEC (this.hConnectHandle, this.cSQL, this.cCursorName)
		IF nError < 0
			this.ProcessError
		ENDIF
		
	ENDPROC

	PROCEDURE getsql		&& Gets results from SPT statement.
		RETURN this.cSQL
		
	ENDPROC

	PROCEDURE Init
		* This class library is used for SQL Pass Thru and can allow you to execute stored procedures
		* on your host database. For example, the sample belows shows how you might want to called a stored
		* procedure called "UpdateAuthorName" on the database "pubs". The result set is returned to a cursor.
		
		*	Sample code
		*!*	sqldisconn(0)
		*!*	DIME aParams[3]
		*!*	aParams[1] = "'172-32-1176'"
		*!*	aParams[2] = "'S'"
		*!*	aParams[3] = "'E'"
		*!*	hConnect = SQLCONNECT ('pubs','sa','')
		*!*	set classlib to HOME()+"classes\utility.vcx"
		*!*	x=createobj('ExecSP', 'UpdateAuthorName', hConnect, @aParams)
		*!*	x.dosql()
		
		PARAMETERS cSPName, hConnectHandle, aParams, cCursorName
		
		IF PCOUNT() < 3
			MESSAGEBOX(BADPARMS_LOC)
			RETURN .F.
		ENDIF
		
		DIMENSION this.aParams[1]
		ACOPY(aParams,this.aParams)
		
		IF NOT EMPTY (m.cSPName)
			this.cSPName = m.cSPName
		ENDIF
		
		this.hConnectHandle = m.hConnectHandle
		
		IF PCOUNT() = 3
			this.cCursorName = 'sqlresult'
		ELSE
			this.cCursorName = m.cCursorName
		ENDIF
		
		this.SetSQL()
		
	ENDPROC

	PROTECTED PROCEDURE processerror
		LOCAL cMessageText
		DIMENSION aSQLError[5]
		
		=AERROR (aSQLError)
		cMessageText = aSQLError[1,2]
		=MESSAGEBOX (cMessageText)
		
	ENDPROC

	PROTECTED PROCEDURE setparams
		LOCAL nArrayCount,cParms
		cParms=""
		FOR nArrayCount = 1 TO ALEN (this.aParams)
			cParms = cParms + this.aParams[nArrayCount]
			IF nArrayCount <> ALEN (this.aParams)
				cParms= cParms + ','
			ENDIF
		ENDFOR
		RETURN cParms
	ENDPROC

	PROTECTED PROCEDURE setsql
		IF THIS.lUseSQLSyntax
			THIS.cSQL = "exec " + this.cSPName	+" " +this.SetParams() &&SQL Server specific
		ELSE
			THIS.cSQL = "{call " + this.cSPName + "("+this.SetParams()+ ")}"
		ENDIF
		
	ENDPROC

ENDDEFINE

DEFINE CLASS _offline AS _container OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="ogOffline" UniqueID="" Timestamp="" />

	#INCLUDE "_data.h"
	*<DefinedPropArrayMethod>
		*m: alert		&& Displays messagebox dialog.
		*m: checkoffline		&& Checks to see if views are currently online/offline.
		*m: gooffline		&& Takes specified views offline.
		*m: goonline		&& Takes specified views online
		*m: setviews
		*p: cdatabase		&& Name of database containing views to take offline.
		*p: lallviews		&& Whether to automatically use all views in database.
		*p: lrevertonfail		&& Whether to revert all views if one fails when going offline.
		*p: lupdateviews		&& Whether to update all views when going online.
		*p: lusecurrentdbc		&& Whether to use currently opened database at start.
		*a: aupdateerrors[1,0]
		*a: cviews[1,0]		&& Array of views to process.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Height = 64
	lrevertonfail = .T.		&& Whether to revert all views if one fails when going offline.
	lupdateviews = .T.		&& Whether to update all views when going online.
	lusecurrentdbc = .T.		&& Whether to use currently opened database at start.
	Name = "_offline"
	Width = 119

	ADD OBJECT 'ogOffline' AS optiongroup WITH ;
		AutoSize = .F., ;
		BorderStyle = 0, ;
		ButtonCount = 2, ;
		Height = 62, ;
		Name = "ogOffline", ;
		Top = 3, ;
		Value = 1, ;
		Width = 122, ;
		Option1.Caption = "Online", ;
		Option1.Height = 59, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.Picture = graphics\online.ico, ;
		Option1.Style = 1, ;
		Option1.Top = 0, ;
		Option1.Value = 1, ;
		Option1.Width = 55, ;
		Option2.Caption = "Offline", ;
		Option2.Height = 59, ;
		Option2.Left = 64, ;
		Option2.Name = "Option2", ;
		Option2.Picture = graphics\offline.ico, ;
		Option2.Style = 1, ;
		Option2.Top = 0, ;
		Option2.Width = 55
		*< END OBJECT: BaseClass="optiongroup" />
	
	PROCEDURE alert		&& Displays messagebox dialog.
		LPARAMETER cMessage
		WAIT WINDOW m.cMessage TIMEOUT 2
	ENDPROC

	PROCEDURE checkoffline		&& Checks to see if views are currently online/offline.
		LOCAL lOffline,i
		
		IF !EMPTY(THIS.cDatabase) AND (SET("DATABASE") # THIS.cDatabase)
			SET DATABASE TO (THIS.cDatabase)
		ENDIF
		
		IF EMPTY(THIS.cDatabase) OR EMPTY(THIS.cViews[1])
			*THIS.Alert(C_NODATABASE_LOC)
			THIS.ogOffline.Option1.Enabled = .F.
			THIS.ogOffline.Option2.Enabled = .F.
			RETURN 
		ENDIF
		
		THIS.ogOffline.Option1.Enabled = .T.
		THIS.ogOffline.Option2.Enabled = .T.
		
		FOR i = 1 TO ALEN(THIS.cViews)
			lOffline = DBGETPROP(THIS.cViews[m.i],"VIEW","OFFLINE")
			IF !lOffline
				EXIT
			ENDIF
		ENDFOR
		
		THIS.ogOffline.value = IIF(m.lOffline,2,1)
		
	ENDPROC

	PROCEDURE gooffline		&& Takes specified views offline.
		LOCAL i,j
		
		IF !EMPTY(THIS.cDatabase) AND (SET("DATABASE") # THIS.cDatabase)
			SET DATABASE TO (THIS.cDatabase)
		ENDIF
		
		IF EMPTY(THIS.cViews[1])
			THIS.Alert(C_NOVIEWS_LOC)
			RETURN .F.
		ENDIF
		
		FOR i = 1 TO ALEN(THIS.cViews)
			* Check if already offline
			IF DBGETPROP(THIS.cViews[m.i],"VIEW","OFFLINE")
				LOOP
			ENDIF
			IF !CREATEOFFLINE(THIS.cViews[m.i])
				THIS.Alert(C_FAILOFFLINE_LOC+THIS.cViews[m.i])
				IF THIS.lRevertOnFail
					FOR j = 1 TO i-1
						DROPOFFLINE(THIS.cViews[m.i])
					ENDFOR
					THIS.ogOffline.value = 1
					RETURN .F.
				ENDIF
			ENDIF
		ENDFOR
		
		THIS.Alert(C_OKOFFLINE_LOC)
		
	ENDPROC

	PROCEDURE goonline		&& Takes specified views online
		LOCAL lUpdateSuccess,lDropSuccess,aUpdateErrors[1],i,lAbort,lAlreadyUsed,nSaveArea
		
		lAbort = .F.
		
		DIMENSION THIS.aUpdateErrors[1]
		THIS.aUpdateErrors[1] = 0
		
		IF !EMPTY(THIS.cDatabase) AND (SET("DATABASE") # THIS.cDatabase)
			SET DATABASE TO (THIS.cDatabase)
		ENDIF
		
		IF EMPTY(THIS.cViews[1])
			THIS.Alert(C_NOVIEWS_LOC)
			RETURN
		ENDIF
		
		nSaveArea = SELECT()
		FOR i = 1 TO ALEN(THIS.cViews)
			* Check if already online
			IF !DBGETPROP(THIS.cViews[m.i],"VIEW","OFFLINE")
				LOOP
			ENDIF
			IF THIS.lUpdateViews
				lAlreadyUsed = USED(THIS.cViews[m.i])
				IF m.lAlreadyUsed 
					SELECT (THIS.cViews[m.i])
				ELSE
					SELECT 0
				ENDIF
				USE (THIS.cViews[m.i]) ONLINE EXCLUSIVE
				IF EMPTY(ALIAS())
					* Failed to open exclusively
					MESSAGEBOX(C_NOOPEN_LOC+THIS.cViews[m.i])
					lAbort = .T.
					EXIT
				ENDIF
				lUpdateSuccess = TableUpdate(2,aUpdateErrors)
				USE IN (THIS.cViews[m.i])
				IF !m.lUpdateSuccess
					ACOPY(aUpdateErrors,THIS.aUpdateErrors)
					MESSAGEBOX(C_RECORDCONLICT_LOC+THIS.cViews[m.i])
					lAbort = .T.
					EXIT
				ENDIF
			ENDIF
			lDropSuccess = DROPOFFLINE(THIS.cViews[m.i])
			IF m.lAlreadyUsed
				USE (THIS.cViews[m.i])
			ENDIF
			IF !m.lDropSuccess
				MESSAGEBOX(C_FAILONLINE_LOC+THIS.cViews[m.i])
				lAbort = .T.
				EXIT
			ENDIF
		ENDFOR
		
		IF m.lAbort
			THIS.ogOffline.value = 2
		ELSE
			THIS.Alert(C_OKONLINE_LOC)
		ENDIF
		SELECT (m.nSaveArea)
		
	ENDPROC

	PROCEDURE Init
		IF THIS.lUseCurrentDBC AND EMPTY(THIS.cDatabase)
			THIS.cDatabase = SET("DATABASE")
		ENDIF
		THIS.SetViews()
		THIS.CheckOffline()
		
	ENDPROC

	PROCEDURE setviews
		* Abstract class to setup THIS.cViews array and THIS.cDatabase (optional)
		IF THIS.lAllViews
			LOCAL aTmpViews,nTotViews
			DIMENSION aTmpViews[1]
			IF !EMPTY(THIS.cDatabase) AND (SET("DATABASE")#THIS.cDatabase)
				SET DATABASE TO (THIS.cDatabase)
			ENDIF
			nTotViews = ADBOBJECT(aTmpViews,"VIEW")
			IF nTotViews>0
				DIMENSION THIS.cViews[1]
				ACOPY(aTmpViews,THIS.cViews)
			ENDIF
		ENDIF
		
	ENDPROC

	PROCEDURE ogOffline.Option1.Click
		THIS.Parent.Parent.GoOnline()
	ENDPROC

	PROCEDURE ogOffline.Option2.Click
		THIS.Parent.Parent.GoOffline()
	ENDPROC

ENDDEFINE

DEFINE CLASS _qbf AS _container OF "_base.vcx" 
 	*< CLASSDATA: Baseclass="container" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="cmdQBFMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdExecuteQBF" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="cmdClearFilter" UniqueID="" Timestamp="" />

	*<DefinedPropArrayMethod>
		*m: parsecondition		&& Filters based on query.
		*p: qbf_table		&& Specifies the table to query against.
	*</DefinedPropArrayMethod>

	BackStyle = 0
	BorderWidth = 0
	Height = 97
	Name = "_qbf"
	qbf_table = 		&& Specifies the table to query against.
	Width = 80

	ADD OBJECT 'cmdClearFilter' AS _commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "\<Clear Filter", ;
		Enabled = .F., ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 4, ;
		Name = "cmdClearFilter", ;
		TabIndex = 25, ;
		Top = 71, ;
		Width = 72
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdExecuteQBF' AS _commandbutton WITH ;
		Caption = "\<Query", ;
		Enabled = .F., ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 4, ;
		Name = "cmdExecuteQBF", ;
		TabIndex = 24, ;
		Top = 31, ;
		Width = 72
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />

	ADD OBJECT 'cmdQBFMode' AS _commandbutton WITH ;
		AutoSize = .F., ;
		Caption = "\<Enter QBF", ;
		FontBold = .F., ;
		FontName = "MS Sans Serif", ;
		FontSize = 8, ;
		Height = 23, ;
		Left = 4, ;
		Name = "cmdQBFMode", ;
		TabIndex = 23, ;
		Top = 3, ;
		Width = 72
		*< END OBJECT: ClassLib="_base.vcx" BaseClass="commandbutton" />
	
	PROCEDURE parsecondition		&& Filters based on query.
		LPARAMETERS cCondition, cControlSource
		LOCAL lcRetCondition, lcFieldName
		IF TYPE('cCondition') = 'C'
			cCondition = ALLTRIM(cCondition)
		ENDIF
		
		lcFieldName = SUBSTRC(cControlSource,(RATC(".",cControlSource)+1))
		
		*!* NOTE: If you add a checkbox, radio button, or command group to
		*!* the form, this routine will need to be changed to handle that
		*!* specific datatype.
		
		IF !EMPTY(cCondition) THEN
			*!* If the type is Character or Memo, check to see if the 
			*!* user has entered a complex condition (if so, take that 
			*!* condition literally without any manipulation
			IF TYPE('cCondition')$ "CM" 
				IF ("<"	 	$ cCondition OR ;
					"==" 	$ cCondition OR ;
					"LIKE" 	$ cCondition OR ;
					"<>" 	$ cCondition OR ;
					"!=" 	$ cCondition OR ;
					"#" 	$ cCondition OR ;
					"=" 	$ cCondition OR ;
					">=" 	$ cCondition OR ;
					"<=" 	$ cCondition OR ;
					">" 	$ cCondition)
				  	lcRetCondition = lcFieldName + cCondition
				ENDIF
			ENDIF
			*!* If a complex condition wasn't found above (lcRetCondition will be empty)
			*!* Then we need to create the WHERE condition ourselves
			IF EMPTY(lcRetCondition)
				*!* The RATC() Functions figure out the column to compare based on the 
				*!* controlSource of the control and any delimiters needed for the 
				*!* datatype are added around the values (not all conditions are
				*!* assumed to be = when we construct them ourselves
				DO CASE
					CASE TYPE(cControlSource) $ "CM"
						lcRetCondition = lcFieldName + " = " + CHR(34) + cCondition + CHR(34)
					CASE TYPE(cControlSource) $ "DT"
						lcRetCondition = lcFieldName + " = {" + DTOC(cCondition) + "}"
					OTHERWISE
						lcRetCondition = lcFieldName + " = " + STR(cCondition)
				ENDCASE	
			ENDIF
		ELSE
			lcRetCondition = ""
		ENDIF
		
		RETURN lcRetCondition
	ENDPROC

	PROCEDURE cmdClearFilter.Click
		
		*!* Clear the filter that was set
		SET FILTER TO
		GO TOP
		THIS.enabled = .F.
		
		THISFORM.Refresh
	ENDPROC

	PROCEDURE cmdExecuteQBF.Click
		LOCAL cFilter,nCnt,cCondition
		cFilter = ""
		
		*!* First, we need to walk all the controls on the form and find
		*!* all controls with a controlSource and has a value in the value property.
		
		FOR nCnt = 1 to THISFORM.ControlCount
			IF TYPE('THISFORM.Controls(nCnt).controlSource') <> "U" THEN
				IF !EMPTY(THISFORM.Controls(nCnt).ControlSource) AND ;
				  TYPE('THISFORM.Controls(nCnt).value') <> "U" THEN
				  
				    *!* Now we need to parse the value property into a proper
				    *!* condition using the parseCondition method of the form
					cCondition = THIS.Parent.parseCondition(THISFORM.Controls(nCnt).value,THISFORM.Controls(nCnt).controlSource)
					
					*!* If there is a condition, add it to are overall filter
					IF !EMPTY(cCondition) THEN
						cFilter = cFilter + " AND " + cCondition
					ENDIF
				ENDIF
			ENDIF
		ENDFOR
		
		*!* We need to rollback the transaction to discard the APPEND'ed record
		ROLLBACK
		
		THIS.Enabled = .F.
		THIS.Parent.cmdQBFMode.Enabled = .T.
		
		*!* This removes the " AND " keyword that is not needed for the 
		*!* first condition added to cFilter
		IF !EMPTY(cFilter) THEN
			cFilter = ALLTRIM(SUBSTRC(cFilter,5))
		ENDIF
		
		*!* Now we are ready to apply the filter
		SET FILTER TO &cFilter
		
		THIS.Parent.cmdClearFilter.enabled = .T.
		
		GO TOP
		THISFORM.Refresh
	ENDPROC

	PROCEDURE cmdQBFMode.Click
		
		*!* In order to clear out all the controls with a controlSource,
		*!* we need to start a transaction and append a record (then when
		*!* we are done we'll rollback the transaction so the new record
		*!* doesn't get added to the table
		
		IF !EMPTY(THIS.Parent.QBF_table) THEN
			SELECT (THIS.Parent.QBF_table)
		ENDIF
		
		BEGIN TRANSACTION
		
		APPEND BLANK
		
		THIS.Enabled = .F.
		
		THIS.Parent.cmdExecuteQBF.Enabled = .T.
		THIS.Parent.cmdClearFilter.enabled = .F.
		
		THISFORM.Refresh
	ENDPROC

ENDDEFINE
